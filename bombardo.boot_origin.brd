# в пространстве бут-скрипта сразу присутствуют все встроенные элементы языка
# но в модулях их нужно будет импортировать
(context.define $CTX$ (context.getContext))
(context.define $CTXModule$  (table.create))

(table.importAll context $CTX$)
(table.importAll console $CTX$)
(table.importAll math $CTX$)
(table.importAll lang $CTX$)

# да, такой изврат, а шо делать если константы пока нигде не определены? :)
(define valNull [nope])
(define valTrue (eq? lambda lambda))
(define valFalse (eq? lambda define))
(define symQuote (quote `))
(define symDot (quote .))

# Фундаментальные препроцессоры
(define RebuildTree (lambda [tree handler]
	(if [pair? tree]
		[cons	(RebuildTree (car tree) handler)
				(RebuildTree (cdr tree) handler)]
		[if [not-null? tree]
			(handler tree)]
	)
))

(define PreprocessNullHandler (lambda [symbol]
	(if [eq? symbol (quote null)]
		valNull
		symbol
	)
))

(define PreprocessNull (lambda [expression]
	(RebuildTree expression PreprocessNullHandler)
))

(define PreprocessBooleanHandler (lambda [symbol]
	(cond	[(eq? symbol (quote true)) valTrue]	
			[(eq? symbol (quote false)) valFalse]
			[valTrue symbol]
	)
))

(define PreprocessBoolean (lambda [expression]
	(RebuildTree expression PreprocessBooleanHandler)
))

(define PreprocessNumbersHandler (lambda [symbol]
	(define number (tryParseNumber symbol))
	(if [number? number] number symbol)
))

(define PreprocessNumbers (lambda [expression]
	(RebuildTree expression PreprocessNumbersHandler)
))

(define RebuildListTree (lambda [tree nodeHandler]
	(if [pair? tree]
		[nodeHandler tree]
		tree)
))

(define PreprocessQuoting (lambda [expression]
	(if [pair? expression]
		[block
			(define iter valNull)
			(while [not-null? expression]
				[define $FIRST (car expression)]
				[define $SECOND (cdr expression)]
				(cond	[(and (eq? $FIRST symQuote) (not-null? $SECOND))
							(set! iter (cons [list (quote quote) (car $SECOND)] iter))
							(set! expression (cdr $SECOND))]
						[valTrue
							(set! iter (cons (PreprocessQuoting $FIRST) iter))
							(set! expression $SECOND)
						]
				)
			)
			(reverse iter)
		]
		expression
	)
))

(define PreprocessDottedPair (lambda [expression]
	(if [pair? expression]
		[block
			(if [eq? (car expression) symDot]
				[error "Wrong dot . expression!"])
			(define iter valNull)
			(while [not-null? expression]
				[define $I1 (car expression)]
				[define $I2 (cadr expression)]
				[define $I3 (caddr expression)]
				[define $E4 (cdddr expression)]
				[define $isDot (eq? $I2 symDot)]
				(cond	[(and $isDot (null? $E4))
							(set! iter (cons (PreprocessDottedPair $I1) iter))
							(set! iter (reverse iter))
							(set-cdr! (end iter) $I3)
							(set! expression valNull)
						]
						[(not $isDot)
							(set! iter (cons (PreprocessDottedPair $I1) iter))
							(set! expression (cdr expression))
							(if (null? expression)
								(set! iter (reverse iter)))
						]
						[valTrue
							(error "Wrong dot . expression!")
						]
				)
			)
			iter
		]
		expression
	)
))

(define PackApply (lambda [functions expression]
	(define PackApplyHandler (lambda [function]
		(set! expression (function expression))
	))
	(each functions PackApplyHandler)
	expression
))

(define $defaultPreprocessors
	(list
		PreprocessNull
		PreprocessBoolean
		PreprocessNumbers
		PreprocessQuoting
		PreprocessDottedPair
	)
)

(define DefaultPreprocess (lambda [expression]
	(PackApply $defaultPreprocessors expression)
))

# Тесты

(print "[TEST.START]")

(define result (DefaultPreprocess
	[quote (block
		(print (+ 1 2 3 4 (- 7 2)))
		(print `(a . (b . c)))
		(print null)
	)]
))

(print "pathToApp: " pathToApp (null? pathToApp))
(print "basePath: " basePath (null? basePath))
(print "pathToBoot: " pathToBoot (null? pathToBoot))
(print "pathToScript: " pathToScript (null? pathToScript))
(print "pathToWorkDirectory: " pathToWorkDirectory (null? pathToWorkDirectory))
(print "Result: " (cons result (eval result)))

(print "[TEST.END]")



# Модульная система
{eval (DefaultPreprocess [quote (block
# Здесь уже обработаны все базовые препроцессинги
# и мы имеем дела с полной базовой версией языка
#
# To implement:
#
# Эти директивы идут в начале файла и должны исполняться не как код а обработчиком
# (preprocess: null)
# (preprocess: default)
# (preprocess: (mod prep))
# (preprocess: (mod prep1 prep2 prep3) .. )
# (preprocess: (mod1 prep1) (mod2 prep2) (mod3 prep3) .. )
# (preprocess: default (mod1 prep1) (mod2 prep2) (mod3 prep3) .. )
#
# Эти директивы уже могут быть уже просто вызовами
# (require "ModuleName")
# (require "ModuleName" as NewName)
# (require "ModuleName" import name1 name2 name3 ...)
# (require "ModuleName" importAll)
#

(define $modulesStack null)
(define $modules (table.create))

#(define handleRequire (lambda null null))

(define LoadPreprocessors (lambda [items]
	(define preprocessors null)
	(define $module (car $modulesStack))
	
	(each items (lambda [item]
		(if [eq? `default item]
			[set! preprocessors (cons DefaultPreprocess preprocessors)]
			[block
				# тут нужно из имени модуля определять путь.
				(define $prep_module (car item))
				(define $names (cdr item))
				
			]
		)
	))
))

(define TryGetModule (lambda [path]
	(define  $module [table.get $modules path])
	(if [not (null? $module)]
		[block
			(if [eq? `loading (table.get $module `status)]
				[error (string.concat "Module '" path "' is loading! Check recursive links!"]
			)
			$module]
		[block
			# 1 создаём новый контейнер модуля
			(define $module [table.create
				(list
					(cons `content [table.create])
					(cons `status `loading)
					(cons `path path)
				)
			])
			(table.set $modules (list
				(cons path $module)
			))
			
			
			# 2 ставим его в стек и помечаем что он грузится
			(set! $modulesStack (cons $module $modulesStack))
			
			
			# 3 грузим модуль вместе с рекурсивными вызовами TryGetModule
			(define moduleContent (fs.readText path))
			(define moduleContent (lang.parse moduleContent))
			
			(define first (car moduleContent))
			
			
			# 3.1 исполняем препроцессинг
			(if [eq? `preprocess: (car first)]
				[block
					# Если файл начинается с директивы препроцессора
					(set! moduleContent (cdr moduleContent))
					
					# Формируем стек препроцессоров
					(define preprocessors null)
					(each (cdr first) (lambda [item]
						(if [eq? `default item]
							[set! preprocessors (cons DefaultPreprocess preprocessors)]
							[block
							# тут нужно из имени модуля определять путь.
							# Стоит вынести в отдельную функцию?
								(define $prep_module (car item))
								(define $names (cdr item))
								
							]
						)
					))
					
					# Применяем препроцессинг
				]
			)
			
			
			# 3.2 исполняем сам файл
			
	
	
			# 4 после загрузки модуля сохраняем его объект export
			
			
			
			# 5 убираем модуль из стека и помечаем загруженным
			(set! $modulesStack (cdr $modulesStack))
			(table.set $module (list
				(cons `status `ready)
			))
			
			# 6 возвращаем его
			$module
		]
	)
))


#(fs.readText pathToScript)

# не теряем скобки!
)])}