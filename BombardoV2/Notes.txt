
		Итак, я хочу преобразовать главный алгоритм из рекурсивного в плоский с явной обработкой стека
		Стек надо представить в виде всё той же лисповой структуры...
		Как происходит исполнение выражения
		
		(
		    (phase expression context)
		    
		    (phase expression context)
		    (phase expression context)
		    (phase expression context)
		    .
		    null
		)
		
		phase:
			-init-
		    -head-
		    -args-
		    -body-
		
		(* (- 5 3) (+ 7 15))
		eval
		()
		
		
		
		Рекурсивный интерпретатор:
		Старт
			Если выражение - атом, то:
				Ищем значение атома
				Если значения нет, то:
					Ошибка
				Возвращаем значение атома
			Если выражение - списов, то:
				Вызываем интерпретацию головы
				Получаем результат
				Если результат - НЕ атом, то:
					Вызываем интерпретацию повторно
				Если результат - НЕ функция, то:
					Ошибка
				Составляем список аргументов
				Если функция требует интерпретацию аргументов, то:
					Для каждого аргумента вызываем интерпретацию
					Соствляем новый список аргументов
				Вызываем функцию со списком аргументов
				Если функция требует интерпретацию результата, то:
					Вызываем интерпретацию результата
				Возвращаем результат
			Если непонятно что, то:
				Ошибка
		
		Если нужно интерпретировать блок кода, то:
			Просто последовательно вызываем интерпретацию каждого элемента блока
			При этом можно собирать все возвращаемые значения
			или только последнее
		
		
		
		
		Нерекурсивный интерпретатор:
		Ставим первое выражение в стек
		Старт
			Если длинна стека больше лимита, то:
				Ошибка
			Если первый вход в кадр на стеке, то:	
				Если текущее выражение в кадре - атом, то:
					Найти значение атома
					снять со стека кадр
					записываем значение атома
					Переходим на Старт
				Если выражение - список, то:
					Взять голову списка
					создать новый кадр стека с выражением в голове текущего
					Переходим на Старт
			Если повторный вход (возврат значения из вложенного вызова), то:		
				Если возврат для головы, то:
					Проверяем что голова - это исполнимая функция
					Если нет, то:
						Ошибка
					Проверяем, требуется ли исполнение аргументов
					Если да, то:
						Инициируем обход аргументов
						создаём кадр с первым аргументом
						Переходим на Старт
					Если нет, то:
						Вызываем функцию с полученным списком аргументов
						Функция возвращает значение
						Если возвращаемое значение требует исполнения, то:	
							Создаём кадр с возвращаемым
							Переходим на Старт
						Если нет, то:
							снимаем со стека кадр
							записываем значение возврата
							Переходим на Старт
				Если возврат для аргумента
					Сохраняем возвращённый аргумент
					Если есть ещё аргументы, то:
						Создаём кадр с новым аргументом
						Переходим на Старт
					Вызываем функцию с полученным списком аргументов
					Функция возвращает значение
					Если возвращаемое значение требует исполнения, то:	
						Создаём кадр с возвращаемым
						Переходим на Старт
					Если нет, то:
						снимаем со стека кадр
						записываем значение возврата
						Переходим на Старт
				Если возврат для результата функции (исполненного), то:
					снимаем со стека кадр
					записываем значение возврата
					Переходим на Старт
		
		Функции которые данный алгоритм исполняет - простые математические функции
			не способные менять окружение
			не способные вызывать исполнение других символьных выражений
			Функция должна принимать аргумент и возвращать значение.
			Никаких побочных эффектов.
		Так же тут не учтены функции написанные на самом языке.
		Для реализации поддержки блоков кода понадобиться писать отдельный набор стейтов.
		
		Что бы реализовать функции вроде условий, циклов, работу с переменными и вызов исполнения
			Придётся расширять набор стейтов для каждого случая ОТДЕЛЬНО
		







2020.06.05
Итак.
Я ранее написал новый интерпретатор на базе стека и стейт-машины.

Теперь же я хочу реализовать систему препроцессинга.

Как я это вижу:

Модульная система остаётся прежней:
  файл = модуль

Поиск модулей производится как прежде.


А дальше появляется новая директива.
Если в начале файла пишеться выражение

(preprocess: (ModuleName PreprocessorName))

то весь последующий код перед своим основным выполнением прогоняется через функцию
PreprocessorName
определённую в модуле ModuleName


директива preprocess должна находится в начале файла
директива поддерживает следующие формы:

- (preprocess: default)
  Использует только вшитый препроцессор и препроцессоры, определённые в специальной папке возле запускного файла
  Отсутствие директивы - эквивалентно этой форме
- (preprocess: (mod prep))
  (preprocess: (mod prep1 prep2 prep3) .. )
  (preprocess: (mod1 prep1) (mod2 prep2) (mod3 prep3) .. )
  Множественное применение препроцессоров.
  Препроцессоры могут повторяться.



Для определения препроцессорных функций я введу новое свойство у функции.
Теперь функции будут иметь теги.

- built-in - тег встроенных функций, определённых через C#
- lambda - тег функций, определённых через:
    (lambda [...] expression)
- macros - тег функций, определённых через:
    (macros [...] expression)
- preprocessor - тег функции, объявляемой специально для препроцессинга
    (preprocessor [...] expression)
- custom-tag - тег, который можно явно задавать через синтаксическую функцию
    (syntax [custom-tag before after] [...] expression)


Таким образом при препроцессинге будут выполнятся такие действия:
1. Импортирование модуля (естесственно с проверной рекурсивности. Нельзя препроцессить модуль самим собой)
2. Поиск в модуле указанных препроцессорных функций
3. Проверка тегов этих функций
4. Если все предыдущие действия не вызвали ошибок - применение препроцессоров к каждому элементу в загружаемом модуле
5. Повторение предыдущих шагов, пока все препроцессоры не будут применены
6. Исполнение полученного кода

На препроцессоры соответственно накладываются ограничения:
Они должны явно понимать как обрабатывать различные типы выражения и порождать валидный код.
Но это уже на совести разработчика.

В дефолтных препроцессорах я реализую следующую логику:
- Нахождение символов, являющихся числами и преобразование в числа
- Нахождение символов, являющихся булевыми значениями и преобразование
// НЕТ - Нахождение вызовов функций, являющихся макросами и применение их.

Последнее вызывает вопросы - для этого есть два пути
- Или импортировать макросы в сам препроцессор
- Или каким-то образом на ходу интерпретировать весь код

Я не знаю как в лиспе это реализуется, но видя те извыращения, которые я там уже встречал - думаю как попало.



2020.06.07

Помимо препроцессора нужно ещё ввести внутреннюю модульную систему, что бы были Built-in модули,
которые можно подключать так же, как внешние.







2020.09.28

Я вернулся!
Иии...
Почитав про макросы в лиспе понял что у меня нормальные макросы были.

А подумав ещё пол часа понял что препроцессор всё же нужен - ибо это НЕ макросы :D



Выше я не проработал такой момент:
У нас встроенный код - build-in модули.

Значит загрузка модулей должна предусматривать этот момент.
Думаю резонно будет иметь такую логику загрузки:

- сначала производится поиск файла модуля
- если он ничего не дал - делается поиск среди встроенных модулей

И тут выплывает вот какой момент.
Допустим у нас есть такая структура проекта:

application.brd
folder_01/
folder_01/submodule.brd
folder_01/lang.brd
folder_02/
folder_02/submodule.brd

Конструкция
(require "lang")

Находясь в каждом из субмодулей должна давать разный результат.

Оптимальная стратегия - обращаться к файлам по абсолютному пути и загруженные модули так же хранить по абсолютному пути.
Соответственно даже при очень хитрых запросах если файл cуществует - он будет найден.
А если нет - то уже ТОГДА будет обращение к встроенным модулям.

Сами встроенные модули имеют очень простую инициализацию.
Однако если я вынесу языковые конструкции в отдельные модули - придётся реализовывать некоторый набор импорта по умолчанию.








2021.01.21
лооол, ну и дата :D

С прошлого раза я так ничерта и не дописал :(

Не до того было...





