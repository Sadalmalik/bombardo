(Вернуться к оглавлению)[/Sadalmalik/README.md#оглавление]

# Структура языка

Как и в обычном Lisp программа состоит из атомов.
Существуют следующие атомы:
  - Точечная пара
  - Символ
  - Число
  - Строка
  - Флаг (Булево значение) (true | false)
  - Функция
  - Нативный объект (ссылается на любой объект C#)

Из точечных пар формируются списки
```lisp
;  Пара атомов symbolA и symbolB
( symbolA . symbolB )

;  Эти две записи эквивалентны
( a . ( b . ( c . null )))
( a b c )
```

Язык поддерживает два типа скобок: круглые и квадратные.
Скобки полностью равнозначны между собой, но нельзя сочетать разные скобки.
```lisp
( exp )  ; Корректно
[ exp ]

( exp ]  ; Некорректно
[ exp )
```

Интерпретатор исполняет программу в некотором контексте, который хранит значения символов.
Контекст является таблицей, в которой символ является ключом, а значение - любой атом или список.

Исполнение программы производится сходным с лисплм образом.
```lisp
( procedureName argument1 argument2 ... )
```

Сначала интерпретатор исполняет голову списка procedureName.
Если в результате исполнения получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
  - вычисляются ли их аргументы перед вызовом
  - вычисляются ли возвращаемое значение

Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:  
* Символы интерпретируются как ключи по которым производится поиск в текущем и родительском контексте. Если значения найти не удалось - исполнение прерывается.  
* Все другие значения (числа, строки, флаги, функции, объекты) остаются без изменений.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора.

```lisp
;  Объявление функции
(lambda (arguments) body )

;  Объявление макроса
(macros (arguments) body )
```

Кроме того есть форма с явным определением флагов исполнения:
```lisp
(syntax (arg res) (arguments) body )
```
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
```
(lambda (arguments) body )
(syntax (true false) (arguments) body )

(macros (arguments) body )
(syntax (false true) (arguments) body )
```












