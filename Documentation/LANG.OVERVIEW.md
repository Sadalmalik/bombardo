[Вернуться на главную](../README.md#оглавление)

# WORK IN PROGRESS

Это обзор языка, здесь я постараюсь кратко описать основные моменты, а так же свои наработки.
Подробное описание всех функций можно найти в [технической документации](DOCUMENTATION.md).

## Оглавление
* [Как запустить](#как-запустить)
* [Немного истории](#немного-истории)
* [Основы языка](#основы-языка)
* [Контексты, Окружение](#контексты-окружение)
* [Модульная система](#модульная-система)
* [Наработки](#наработки)

---

### Как запустить
[к оглавлению](#оглавление)

Проект собран в Visual Studio 2017
Для начала откройте Bombardo.sln в Studio и соберите проект.
Назначьте автозагружаемым проектом BombardoApp и можно запускать.
Вы увидите консоль в режиме REPL

![Console](https://github.com/Sadalmalik/bombardo/blob/master/Documentation/Console.png?raw=true)

Введите:
```scheme
(print "Hacked!")
```
Вы увидите
```scheme
Hacked!
null
```
Сначала вывелась строка, затем результат исполнения функции.  
Если всё сработало - можете начинать экспериментировать!  
Ознакомьтесь с нижележащим текстом и тех. документацией!

Для того что бы ознакомится с примерами откройте папку Examples и запустите скрипт CopyApp.cmd - он скопирует приложение в папку Examples\Bombardo, где объявлены различные модули.

---

### Немного истории
[к оглавлению](#оглавление)

Началось всё с того что я увлёкся идеей искусственного интеллекта.
Сначала стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.

В качестве основы я выбрал семантические сети и уже от них начал экспериментировать.
После многих итераций у меня даже получилась некая база знаний, задающая вопросы (очень глупые)

В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) пришло окончательное понимание, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.

Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.

---

## Основы языка
[к оглавлению](#оглавление)

Как и в обычном Lisp программа состоит из символьных выражений, которые состоят из атомов.

Существуют следующие атомы:
  - Точечная пара
  - Символ
  - Число
  - Строка
  - Флаг (Булево значение) (true | false)
  - Функция
  - Нативный объект (ссылается на любой объект C#)

Точечная пара обозначается в коде следующим образом:
```scheme
;  Пара атомов symbolA и symbolB
( symbolA . symbolB )
```
Список является цепочкой пар.  
Для удобства запили лишние точки и скобки сокращаются.
```scheme
;  Эти две записи эквивалентны
( a . ( b . ( c . null )))
( a b c )
```

Язык поддерживает два типа скобок: круглые и квадратные.
Скобки полностью равнозначны между собой, но нельзя сочетать разные скобки.
```lisp
( exp )  ; Корректно
[ exp ]

( exp ]  ; Некорректно
[ exp )
```

Символьное выражение является списком, голова которого интерпретируется как функция.

Исполнение программы производится сходным с лисплм образом.
```lisp
( procedureName argument1 argument2 ... )
```

Сначала интерпретатор исполняет голову списка procedureName.
Если в результате получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
  - вычисляются ли их аргументы перед вызовом
  - вычисляются ли возвращаемое значение

Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:  
* Символы интерпретируются как ключи по которым производится поиск в текущем и родительском контексте.  
Если значения найти не удалось - исполнение прерывается.  
* Все другие значения (числа, строки, флаги, функции, объекты) остаются без изменений.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора. Но в будущем возможно будет исправлено.

```lisp
;  Объявление функции
(lambda (arguments) body )

;  Объявление макроса
(macros (arguments) body )
```

Кроме того есть форма с явным определением флагов исполнения:
```lisp
(syntax (arg res) (arguments) body )
```
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
```
(lambda (arguments) body )
(syntax (true false) (arguments) body )

(macros (arguments) body )
(syntax (false true) (arguments) body )
```

---

### Контексты, Окружение
[к оглавлению](#оглавление)

Исполнение s-выражений всегда происходит в некотором контексте.
Контекст является таблицей, хранящей пары ключ-значение, где ключ - произвольная строка, а значение - любой атом.
Как было сказано выше - интерпретируя символ интерпретатор просто находит в текущем или родительских контекстах значение для данного символа.
У каждого контекста есть родительский контекст.

Самый верхний контекст - корневой, в нём объявлены все основные функции языка и он всегда является последнем родителем в цепочке всех контекстов.  
Корневой контекст нельзя изменить с помощью **set!** - это приведёт к ошибке.

Когда создаётся новая функция - она запоминает текущий контекст. При исполнении функция создаёт новый, дочерний запомненному контекст, в который заносятся аргументы функции.

Когда я изучал лисп - не совсем понял сокральный смысл **let**. 
В моей реализации внутри функции создаётся контекст, ничем не отличающийся от других, так же доступный для модификации.

Функции **define** и **set!** работают в текущем контексте и изменяют его и его родителей соответственно.
Таким образом вызов define внутри функции будет менять внутренний контекст функции. Следовательно надобности в специальной конструкции нет (хотя для тренировки сдлал её реализацию).
```scheme
(define myFunc (lambda [$arg1 $arg2 $arg3]
    ;  Все аргументы объявляются во внутреннем контексте функции
    ;  Контекст создаётся при каждом вызове
    (define $var1 ...)  ;  Объявляет переменную во внутреннем контексте
    (define $var2 ...)
    (define $var3 ...)
	(doSomething ...)   ;
    (set! $arg1 ...)    ;  Поскольку аргументы определены в данном контексте - их можно изменять
	(generate final result)
))
```

Важно заметить что **define** не делает никаких проверок - он лишь создаёт переменную в текущем контексте.
**set!** же ничего не создаёт, а только изменяет. Если в текущем контексте не была найдена переменная - **set!** попытается найти её в родительском контексте. Если ни в одном из родительских контекстов не было найдено переменной - **set!** вызовет ошибку.
Итого: для изменения значения переменной можно использовать как **set!** так и **define**, но **set!** требует что бы переменная хотя бы один раз была объявлена через **define**.

---

### Модульная система
[к оглавлению](#оглавление)

Модульная система реализована очень похоже на модульную систему node.js  
Код пишется в файлах с расширением _.brd_. Каждый файл является самостоятельным модулем.
Каждый файл исполняется в новом контексте, содержащем две переменных:
* #path - содержит путь к данному файлу
* module - таблица экспорта. Все экспортируемые символы заносятся в неё.




---

### Наработки
[к оглавлению](#оглавление)








