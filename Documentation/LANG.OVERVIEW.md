[Вернуться на главную](../README.md#добро-пожаловать)

# WORK IN PROGRESS

Это обзор языка, здесь я постараюсь кратко описать основные моменты, а так же свои наработки.
Подробное описание всех функций можно найти в [технической документации](DOCUMENTATION.md).

## Оглавление
* [Как запустить](#как-запустить)
* [Немного истории](#немного-истории)
* [Основы языка](#основы-языка)
* [Контексты, Окружение](#контексты-окружение)
* [Модульная система](#модульная-система)
* [Наработки](#наработки)

---

### Как запустить
[к оглавлению](#оглавление)

Проект собран в Visual Studio 2017  
Для начала откройте Bombardo.sln в Studio и соберите проект.  
Назначьте автозагружаемым проектом BombardoApp и можно запускать.  
Вы увидите консоль в режиме REPL:
![Console](https://github.com/Sadalmalik/bombardo/blob/master/Documentation/Console.png?raw=true)

Введите:
```scheme
(print "Hacked!")
```
Вы увидите
```scheme
Hacked!
null
```
Сначала вывелась строка, затем результат исполнения функции.  
Если всё сработало - можете начинать экспериментировать!  
Ознакомьтесь с нижележащим текстом и тех. документацией!

Для того что бы ознакомится с примерами откройте папку Examples и запустите скрипт CopyApp.cmd - он скопирует приложение в папку Examples\Bombardo, где объявлены различные модули.

---

### Немного истории
[к оглавлению](#оглавление)

Началось всё с того что я увлёкся идеей искусственного интеллекта.
Сначала стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.

В качестве основы я выбрал семантические сети и уже от них начал экспериментировать.
После многих итераций у меня даже получилась некая база знаний, задающая вопросы (очень глупые)

В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) пришло окончательное понимание, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.

Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.
В последствии засел за SICP и уже под его влиянием доделывал многие элементы.

---

## Стиль кода
[к оглавлению](#оглавление)

Начав экспериментировать с lisp я оценил возможность писать в именах все подряд символы.  
Но впоследствии почувствовал что визуально код буд-то замусоривается. Поскольку я работаю с самописным языком - у меня нет встроенной подсветки, так что нетекстовые символы ощутимо цепляют глаза.  
Поэтому я принял решение об общем стиле моего **bombardo** кода.

Закрывающие скобки по возможности располагаются на отдельных строках, подчёркивая собой блоки кода.

Все имена - **CamelCase**. Встроенные функции начинаются с маленькой буквы, объявленные - с большой. 
Никаких дефисов и иных спец-символов внутри имён. Если вам это кажется неудобным - вы можете для своих экспериментов переименовать имена всех реализованных частей языка в файле **AllNames.cs** как вам будет угодно.
Переменные начинаются со знака $, константы #
Примеры:
```scheme
;  Исключением стали три функции:
(set-car! ...)
(set-cdr! ...)
(macro-expand ...)

;  Если функция меняет состояние контекста или части переменных - её имя оканчивается на восклицательный знак:
(set! ...)
(inc! ...)
(set-car! ...)

;  Имена предикатов заканчиваются на знак вопроса:
(string? "string")

; Функции приведения заканчиваются на двоеточик: (пока есть только числовые приведения)
(ushort: -1354)

;  Объявление переменной
(define $temp `(a b c))

;  Пример объявление функции нахождения площади круга
(define CircleArea (lambda [$radius]
    (* #PI (pow $radius 2))
))

;  Так же есть макрос для сокращённой записи объявления функции,
;  его можно испортировать и использовать для небольшого упрощения записи:
(require "BaseLang" importAll)
(defFunct   [CircleArea $radius]
            [* #PI (pow $radius 2)]
)

;  Более сложный пример кода, нахождение длинны списка:
(defFunct   [Length $list]
    (if     [null? $list]
	        0   ;  Если аргумент null - 0, иначе прибавляем 1 к длинне хвоста списка:
	        [+ 1 (Length (cdr $list))]
	)
)

```

Повторюсь - это не правила, а мои рекомендации по стилю кода для моего же языка.

---

## Основы языка
[к оглавлению](#оглавление)

Как и в обычном Lisp программа состоит из символьных выражений, которые состоят из атомов.

Существуют следующие атомы:
  - Точечная пара
  - Символ
  - Число
  - Строка
  - Флаг (Булево значение) (true | false)
  - Функция
  - Нативный объект (ссылается на любой объект C#)

Точечная пара обозначается в коде следующим образом:
```scheme
;  Пара атомов symbolA и symbolB
( symbolA . symbolB )
```
Список является цепочкой пар.  
Для удобства запили лишние точки и скобки сокращаются.
```scheme
;  Эти две записи эквивалентны
( a . ( b . ( c . null )))
( a b c )
```

Язык поддерживает два типа скобок: круглые и квадратные.
Скобки полностью равнозначны между собой, но нельзя сочетать разные скобки.
```lisp
( exp )  ; Корректно
[ exp ]

( exp ]  ; Некорректно
[ exp )
```

Символьное выражение является списком, голова которого интерпретируется как функция.

Исполнение программы производится сходным с лисплм образом.
```lisp
( procedureName argument1 argument2 ... )
```

Сначала интерпретатор исполняет голову списка procedureName.
Если в результате получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
  - вычисляются ли их аргументы перед вызовом
  - вычисляются ли возвращаемое значение

Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:  
* Символы интерпретируются как ключи по которым производится поиск в текущем и родительском контексте.  
Если значения найти не удалось - исполнение прерывается.  
* Все другие значения (числа, строки, флаги, функции, объекты) остаются без изменений.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора. Но в будущем возможно будет исправлено.

```lisp
;  Объявление функции
(lambda (arguments) body )

;  Объявление макроса
(macros (arguments) body )
```

Кроме того есть форма с явным определением флагов исполнения:
```lisp
(syntax (arg res) (arguments) body )
```
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
```
(lambda (arguments) body )
(syntax (true false) (arguments) body )

(macros (arguments) body )
(syntax (false true) (arguments) body )
```

---

### Контексты, Окружение
[к оглавлению](#оглавление)

Исполнение s-выражений всегда происходит в некотором контексте.
Контекст является таблицей, хранящей пары ключ-значение, где ключ - произвольная строка, а значение - любой атом.
Как было сказано выше - интерпретируя символ интерпретатор просто находит в текущем или родительских контекстах значение для данного символа.
У каждого контекста есть родительский контекст.

Самый верхний контекст - корневой, в нём объявлены все основные функции языка и он всегда является последнем родителем в цепочке всех контекстов.  
Корневой контекст нельзя изменить с помощью **set!** - это приведёт к ошибке.

Когда создаётся новая функция - она запоминает текущий контекст. При исполнении функция создаёт новый, дочерний запомненному контекст, в который заносятся аргументы функции.

Когда я изучал лисп - не совсем понял сокральный смысл **let**. 
В моей реализации внутри функции создаётся контекст, ничем не отличающийся от других, так же доступный для модификации.

Функции **define** и **set!** работают в текущем контексте и изменяют его и его родителей соответственно.
Таким образом вызов define внутри функции будет менять внутренний контекст функции. Следовательно надобности в специальной конструкции нет (хотя для тренировки сдлал её реализацию).
```scheme
(define myFunc (lambda [$arg1 $arg2 $arg3]
    ;  Все аргументы объявляются во внутреннем контексте функции
    ;  Контекст создаётся при каждом вызове
    (define $var1 ...)  ;  Объявляет переменную во внутреннем контексте
    (define $var2 ...)
    (define $var3 ...)
	(doSomething ...)   ;
    (set! $arg1 ...)    ;  Поскольку аргументы определены в данном контексте - их можно изменять
	(generate final result)
))
```

Важно заметить что **define** не делает никаких проверок - он лишь создаёт переменную в текущем контексте.
**set!** же ничего не создаёт, а только изменяет. Если в текущем контексте не была найдена переменная - **set!** попытается найти её в родительском контексте. Если ни в одном из родительских контекстов не было найдено переменной - **set!** вызовет ошибку.
Итого: для изменения значения переменной можно использовать как **set!** так и **define**, но **set!** требует что бы переменная хотя бы один раз была объявлена через **define**.

---

### Синтаксический сахар таблиц
[к оглавлению](#оглавление)

Язык **Bombardo** поддерживает синтаксический сахар для обращения к значениям таблиц.
Этот синтаксис очень схож с синтаксисом обращения к полям объектов в **JavaScript**.
Если есть таблица, то добавляя через точку имена можно обращаться к значениям в таблице и вложенным таблицам.
```scheme
;  Например у нас есть таблица table
;  Тогда новое значение можно добавить следуюшим образом:
(define table.variable `value)
;  Что эквивалентно записи
(tableSet table `(variable value))
```
Такой синтаксический сахар позволяет реализовывать более простые и очевидные конструкции.

Важно заметить что точка здесь является частью символа.  
Недопустимо вставлять в выражение разделители - иначе вы получите разные символы.

Функция **define** может определять вложенные таблицы, при необходимости создавая их. Но таблица не создаётся для первой переменной.
```scheme
(define temp (table))
;  Выражение
(define temp.x.y.z 15)
;  Создаст в таблице temp таблицу x, внутри которой будет таблица y, внутри которой будет значение z равное 15

;  Однако объявление 
(define undefinedName.x.y.z 15)
;  Закончится ошибкой
```

---

### Модульная система
[к оглавлению](#оглавление)

Модульная система реализована очень похоже на модульную систему *node.js*.

Код пишется в файлах с расширением **.brd**.  
Каждый файл является самостоятельным модулем.  
Каждый файл исполняется в новом контексте, содержащем две переменных:
* #path - содержит путь к данному файлу
* module - таблица экспорта. Все экспортируемые символы заносятся в неё.
По завершении исполнения значение переменной **module** сохраняется и отдаётся всем кто подключает данный модуль.

Для подключения модуля используется следующие конструкции:
```scheme
;  Подключение без параметров добавляет в текущий контекст переменную ModuleName с модулем
(require "ModuleName")

;  конструкция as Name указывает под каким именем добавить модуль
(require "ModuleName" as NewName)

;  конструкция import name указывает имена конкретных атомов,
;  которые нужно получить из модуля и добавляет их в текущий контекст
(require "ModuleName" import name1 name2 name3 ...)

;  importAll импортирует все атомы объявленные в модуле
(require "ModuleName" importAll)
```

Как и в *node.js* поиск файла для подключения производится по определённым правилам, поддерживая определённую структуру проекта.
Поиск производится в следующем порядке до нахождения файла:
* Если в названии модуля указано расширение .brd то
  - Сначала файл ищется в текущей папке
  - Затем в подпапке **modules**
  - Затем в папке, где находится *BombardoApp.exe*
  - Затем в подпапке **modules** в папке с *BombardoApp.exe*
* Если расширения нет
  - Сначала добавляется и поиск производится как в варианте с расширением
  - Затем в текущей папке ищется подпапка с данным названием и в ней ищется файл index.brd
  - Затем подпапка с данным названием ищется в **modules** и в ней ищется файл index.brd
  - Затем подпапка с данным названием ищется в папке с *BombardoApp.exe* и в ней ищется файл index.brd
  - Затем подпапка с данным названием ищется в **modules* в папке с *BombardoApp.exe* и в ней ищется файл index.brd

Если после всего этого файл модуля так и не был найден - происходит ошибка.  
Модуль исполняется один раз, после чего он хранится в памяти и при последующих вызовах не происходит повторное исполнение.

Для создания модуля достаточно просто создать новый файл и экспортировать какой-либо атом.
Для экспорта используется конструкция:
```scheme
(define MyStuff `something)
(export MyStuff)
;  Что по сути является синтаксическим сахаром для выражения
(define module.MyStuff MyStuff)
```

Таким образом пример выше - простейший модуль, экспортирующий переменную MyStuff.

Отдельная возможность - напрямую заменить значение **module** - так сделано в примере с созданием класса
```scheme
(define Class (macros $sexp
	...
))
(define module Class)
```
После чего для использования класса можно вызывать require без дополнительных аргументов:
```scheme
(require "Class")

(define myClass (Class ...))
```

---

### Наработки
[к оглавлению](#оглавление)








