[Вернуться на главную](../README.md#добро-пожаловать)

# WORK IN PROGRESS

Это обзор языка, здесь я постараюсь кратко описать основные моменты, а так же свои наработки.
Подробное описание всех функций можно найти в [технической документации](DOCUMENTATION.md).

## Оглавление
* [Как запустить](#как-запустить)
* [Немного истории](#немного-истории)
* [Основы языка](#основы-языка)
* [Стиль кода](#стиль-кода)
* [Контексты, Окружение](#контексты-окружение)
* [Синтаксический сахар таблиц](#синтаксический-сахар-таблиц)
* [Модульная система](#модульная-система)
* [Ошибки](#ошибки)
* [Наработки](#наработки)

---

### Как запустить
[к оглавлению](#оглавление)

Проект собран в Visual Studio 2017  
Для начала откройте Bombardo.sln в Studio и соберите проект.  
Назначьте автозагружаемым проектом BombardoApp и можно запускать.  
Вы увидите консоль в режиме REPL:
![Console](https://github.com/Sadalmalik/bombardo/blob/master/Documentation/Console.png?raw=true)

Введите:
```scheme
(print "Hacked!")
```
Вы увидите
```scheme
Hacked!
null
```
Сначала вывелась строка, затем результат исполнения функции.  
Если всё сработало - можете начинать экспериментировать!  
Ознакомьтесь с нижележащим текстом и тех. документацией!

Для того что бы ознакомится с примерами откройте папку Examples и запустите скрипт CopyApp.cmd  
Он скопирует приложение в папку Examples\Bombardo, где объявлены различные модули.

Ядро языка оформлено в виде отдельной **.dll**, которую должно быть удобно встраивать в различные другие проекты.
После подключения **.dll** в коде любого C# проекта можно написать
```C#
BombardoLangClass.Init(true);
BombardoLangClass.ExecuteFile("path to your file");
```
Этого достаточно что бы выполнить файл.
В проекте BombardoApp можно посмотреть как добавлять новые атомы в корневой контекст, расширяя тем самым язык под свои нужды.

---

### Немного истории
[к оглавлению](#оглавление)

Началось всё с того что я увлёкся идеей искусственного интеллекта.
Сначала стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.

В качестве основы я выбрал семантические сети и уже от них начал экспериментировать.
После многих итераций у меня даже получилась некая база знаний, задающая вопросы (очень глупые)

В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) пришло окончательное понимание, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.

Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.
В последствии засел за SICP и уже под его влиянием доделывал многие элементы.

---

### Основы языка
[к оглавлению](#оглавление)

Как и в обычном Lisp программа состоит из символьных выражений, которые состоят из атомов.

Существуют следующие атомы:
  - Точечная пара
  - Символ
  - Число (по умолчанию число представленно в виде long int)
  - Строка
  - Флаг (Булево значение) (true | false)
  - Функция
  - Нативный объект (ссылается на любой объект C#)

Точечная пара обозначается в коде следующим образом:
```scheme
;  Пара атомов symbolA и symbolB
( symbolA . symbolB )
```
Список является цепочкой пар.  
Для удобства запили лишние точки и скобки сокращаются.
```scheme
;  Эти две записи эквивалентны
( a . ( b . ( c . null )))
( a b c )
```

Язык поддерживает два типа скобок: круглые и квадратные.
Скобки полностью равнозначны между собой, но нельзя сочетать разные скобки.
```lisp
( exp )  ; Корректно
[ exp ]

( exp ]  ; Некорректно
[ exp )
```

Символьное выражение является списком, голова которого интерпретируется как функция.

Исполнение программы производится сходным с лисплм образом.
```lisp
( procedureName argument1 argument2 ... )
```

Сначала интерпретатор исполняет голову списка procedureName.
Если в результате получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
  - вычисляются ли их аргументы перед вызовом
  - вычисляются ли возвращаемое значение

Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:  
* Символы интерпретируются как ключи по которым производится поиск в текущем и родительском контексте.  
Если значения найти не удалось - исполнение прерывается.  
* Все другие значения (числа, строки, флаги, функции, объекты) остаются без изменений.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора. Но в будущем возможно будет исправлено.

```lisp
;  Объявление функции
(lambda (arguments) body )

;  Объявление макроса
(macros (arguments) body )
```

Кроме того есть форма с явным определением флагов исполнения:
```lisp
(syntax (arg res) (arguments) body )
```
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
```
(lambda (arguments) body )
(syntax (true false) (arguments) body )

(macros (arguments) body )
(syntax (false true) (arguments) body )
```

Макрос по сути является функцией, которая должна порождать новое s-выражение, предназначенное для исполнения в месте и контексте вызова макроса.


---

### Стиль кода
[к оглавлению](#оглавление)

Начав экспериментировать с lisp я оценил возможность писать в именах все подряд символы.  
Но впоследствии почувствовал что визуально код буд-то замусоривается. Поскольку я работаю с самописным языком - у меня нет встроенной подсветки, так что нетекстовые символы ощутимо цепляют глаза.  
Поэтому я принял решение об общем стиле моего **bombardo** кода.

Прежде всего - в начале файла записываю строковой атом с именем этого файла. Как оказалось, при исполнении блока кода в него можно просто класть атомы, не являющиеся символами и списками, что дало такую упрощённую систему коментирования, позволяя в то же время оставлять в начале модулей описания, которые в последствии можно получить в виде всё тех же атомов.
Имя файла в начале файла я использовал при отладке парсинга модулей. Эта практика показалась мне удобной.  
При необходимости можно добавить ещё какие-то специальные объявления. Кроме того такие же объявления можно спокойно делать в блоках кода (тело lambda/macro/block).

Закрывающие скобки по возможности располагаются на отдельных строках, подчёркивая собой блоки кода.

Все имена - **CamelCase**. Встроенные функции начинаются с маленькой буквы, объявленные - с большой.  
Никаких дефисов и иных спец-символов внутри имён. Если вам это кажется неудобным - вы можете для своих экспериментов переименовать имена всех реализованных частей языка в файле **AllNames.cs** как вам будет угодно.  
Переменные начинаются со знака **$**, константы **#**  
Примеры:
```scheme
;  Исключением стали три функции:
(set-car! ...)
(set-cdr! ...)
(macro-expand ...)

;  Если функция меняет состояние контекста или части переменных - её имя оканчивается на восклицательный знак:
(set! ...)
(inc! ...)
(set-car! ...)

;  Имена предикатов заканчиваются на знак вопроса:
(string? "string")

; Функции приведения заканчиваются на двоеточик: (пока есть только числовые приведения)
(ushort: -1354)

;  Объявление переменной
(define $temp `(a b c))

;  Пример объявление функции нахождения площади круга
(define CircleArea (lambda [$radius]
    (* #PI (pow $radius 2))
))

;  Так же есть макрос для сокращённой записи объявления функции,
;  его можно испортировать и использовать для небольшого упрощения записи:
(require "BaseLang" importAll)
(defFunct   [CircleArea $radius]
            [* #PI (pow $radius 2)]
)

;  Более сложный пример кода, нахождение длинны списка:
(defFunct   [Length $list]
    (if     [null? $list]
            0   ;  Если аргумент null - 0, иначе прибавляем 1 к длинне хвоста списка:
            [+ 1 (Length (cdr $list))]
    )
)

```

Повторюсь - это не правила, а мои рекомендации по стилю кода для моего же языка.

---

### Контексты, Окружение
[к оглавлению](#оглавление)

Исполнение s-выражений всегда происходит в некотором контексте.
Контекст является таблицей, хранящей пары ключ-значение, где ключ - произвольная строка, а значение - любой атом.
Как было сказано выше - интерпретируя символ интерпретатор просто находит в текущем или родительских контекстах значение для данного символа.
У каждого контекста есть родительский контекст.

Самый верхний контекст - корневой, в нём объявлены все основные функции языка и он всегда является последнем родителем в цепочке всех контекстов.  
Корневой контекст нельзя изменить с помощью **set!** - это приведёт к ошибке.

Когда создаётся новая функция - она запоминает текущий контекст. При исполнении функция создаёт новый, дочерний запомненному контекст, в который заносятся аргументы функции.

Когда я изучал лисп - не совсем понял сокральный смысл **let**. 
В моей реализации внутри функции создаётся контекст, ничем не отличающийся от других, так же доступный для модификации.

Функции **define** и **set!** работают в текущем контексте и изменяют его и его родителей соответственно.
Таким образом вызов define внутри функции будет менять внутренний контекст функции. Следовательно надобности в специальной конструкции нет (хотя для тренировки сдлал её реализацию).
```scheme
(define myFunc (lambda [$arg1 $arg2 $arg3]
    ;  Все аргументы объявляются во внутреннем контексте функции
    ;  Контекст создаётся при каждом вызове
    (define $var1 ...)  ;  Объявляет переменную во внутреннем контексте
    (define $var2 ...)
    (define $var3 ...)
    (doSomething ...)   ;
    (set! $arg1 ...)    ;  Поскольку аргументы определены в данном контексте - их можно изменять
    (generate final result)
))
```

Важно заметить что **define** не делает никаких проверок - он лишь создаёт переменную в текущем контексте.
**set!** же ничего не создаёт, а только изменяет. Если в текущем контексте не была найдена переменная - **set!** попытается найти её в родительском контексте. Если ни в одном из родительских контекстов не было найдено переменной - **set!** вызовет ошибку.
Итого: для изменения значения переменной можно использовать как **set!** так и **define**, но **set!** требует что бы переменная хотя бы один раз была объявлена через **define**.

---

### Синтаксический сахар таблиц
[к оглавлению](#оглавление)

Язык **Bombardo** поддерживает синтаксический сахар для обращения к значениям таблиц.
Этот синтаксис очень схож с синтаксисом обращения к полям объектов в **JavaScript**.
Если есть таблица, то добавляя через точку имена можно обращаться к значениям в таблице и вложенным таблицам.
```scheme
;  Например у нас есть таблица table
;  Тогда новое значение можно добавить следуюшим образом:
(define table.variable `value)
;  Что эквивалентно записи
(tableSet table `(variable value))
```
Такой синтаксический сахар позволяет реализовывать более простые и очевидные конструкции.

Важно заметить что точка здесь является частью символа.  
Недопустимо вставлять в выражение разделители - иначе вы получите разные символы.

Функция **define** может определять вложенные таблицы, при необходимости создавая их. Но таблица не создаётся для первой переменной.
```scheme
(define temp (table))
;  Выражение
(define temp.x.y.z 15)
;  Создаст в таблице temp таблицу x, внутри которой будет таблица y, внутри которой будет значение z равное 15

;  Однако объявление 
(define undefinedName.x.y.z 15)
;  Закончится ошибкой
```

---

### Модульная система
[к оглавлению](#оглавление)

Модульная система реализована очень похоже на модульную систему *node.js*.

Код пишется в файлах с расширением **.brd**.  
Каждый файл является самостоятельным модулем.  
Каждый файл исполняется в новом контексте, содержащем две переменных:
* #path - содержит путь к данному файлу
* module - таблица экспорта. Все экспортируемые символы заносятся в неё.
По завершении исполнения значение переменной **module** сохраняется и отдаётся всем кто подключает данный модуль.

Для подключения модуля используется следующие конструкции:
```scheme
;  Подключение без параметров добавляет в текущий контекст переменную ModuleName с модулем
(require "ModuleName")

;  конструкция as Name указывает под каким именем добавить модуль
(require "ModuleName" as NewName)

;  конструкция import name указывает имена конкретных атомов,
;  которые нужно получить из модуля и добавляет их в текущий контекст
(require "ModuleName" import name1 name2 name3 ...)

;  importAll импортирует все атомы объявленные в модуле
(require "ModuleName" importAll)
```

Как и в *node.js* поиск файла для подключения производится по определённым правилам, поддерживая определённую структуру проекта.
Поиск производится в следующем порядке до нахождения файла:
* Если в названии модуля указано расширение .brd то
  - Сначала файл ищется в текущей папке
  - Затем в подпапке **modules**
  - Затем в папке, где находится *BombardoApp.exe*
  - Затем в подпапке **modules** в папке с *BombardoApp.exe*
* Если расширения нет
  - Сначала добавляется и поиск производится как в варианте с расширением
  - Затем в текущей папке ищется подпапка с данным названием и в ней ищется файл **index.brd**
  - Затем подпапка с данным названием ищется в **modules** и в ней ищется файл **index.brd**
  - Затем подпапка с данным названием ищется в папке с *BombardoApp.exe* и в ней ищется файл **index.brd**
  - Затем подпапка с данным названием ищется в **modules** в папке с *BombardoApp.exe* и в ней ищется файл **index.brd**

Если после всего этого файл модуля так и не был найден - происходит ошибка.  
Модуль исполняется один раз, после чего он хранится в памяти и при последующих вызовах не происходит повторное исполнение.

Для создания модуля достаточно просто создать новый файл и экспортировать какой-либо атом.
Для экспорта используется конструкция:
```scheme
(define MyStuff `something)
(export MyStuff)
;  Что по сути является синтаксическим сахаром для выражения
(define module.MyStuff MyStuff)
```

Таким образом пример выше - простейший модуль, экспортирующий переменную MyStuff.

Отдельная возможность - напрямую заменить значение **module** - так сделано в примере с созданием класса
```scheme
(define Class (macros $sexp
    ...
))
(define module Class)
```
После чего для использования класса можно вызывать require без дополнительных аргументов:
```scheme
(require "Class")

(define myClass (Class ...))
```

---

### Ошибки
[к оглавлению](#оглавление)

Ошибки реализованны как исключения самого C#, поднимающиеся по цепочке исполнения.  
При возникновении исключения составляется стек вызовов, состоящий из всех вложенных s-выражений.

Обработка ошибок на уровне языка пока **не реализована**.
При возникновении ошибки исполнение полностью прерывается и ошибка выводится в консоль.
При этом выводится два стека - один для s-выражений, второй для кода C#

---

### Наработки
[к оглавлению](#оглавление)

В процессе создания языка я сразу задавался вопросом "чо тут интересного можно сделать?".  
Все реализации можно найти в папке **Examples**.

#### Обработка аргументов
Прежде всего заметка про аргументы: аргументы передаются в функцию в виде списка, который затем разбивается на отдельные аргументы.  
Для удобства создания особых синтаксических конструкций я позволил вместа списка аргументов объявлять одну переменную, в которую они будут передаваться.
```scheme
(lambda $args
    body
)
```
Для функций это мало применимо, ведь их аргументы исполняются перед вызовом.  
Зато в макросах это позволяет создавать и обрабатывать свои собственные синтаксические конструкции.  
```scheme
(define do (macro $args
    (cond   [(eq? (car $args) `first) (print "first")]
            [(eq? (car $args) `second) (print "second")])
))

;  Здесь не нужно квотировать второй символ
(do first)  ;  first
(do second) ;  second
```
Таким образом можно по необходимости реализовать конструкции на подобие
```scheme
(for $i from $a to $b body)
```
Следует однако учитывать что передаётся именно исходное выражение.  
И если в синтаксической конструкции требуется получить значение переменной - придётся продумывать часть кода, которая будет исполняться.  
Следующий пример как раз демонстрирует использование макроса.  
(Однако синтаксическая конструкция неотличима от таковой для lambda)

#### Классы
Первое что я реализовал - ООП.  
Реализация опять же схожа с реализацией объектов в **JavaScript**  
Функция, являющаяся конструктором класса, порождает объект (таблицу) и возвращает её.  
```scheme
(define Point (lambda [x y]
    (define this (table))
    (define this.x x)
    (define this.y y)
    this    ;  просто возвращает объект
))
```
Однако каждый раз объявлять this - не удобно. Поэтому можно упаковать объявление в макрос.  
(реализация из **Bombardo/modules/Class.brd**)

```scheme
;  Class как и lambda принимает список аргументов и тело конструктора
(define Class (macros $sexp
    ;  Сначала достаём список аргументов и тело конструктора класса
    (define $args (car $sexp))
    (define $body (cdr $sexp))
    ;  Теперь присоединяем в начало тела объявление this
    (set! $body (cons `(define this (table)) $body))
    ;  А в конец - возвращение this из конструктора
    (set-cdr! (last $body) `(this))
    ;  Составляется новое выражение конструктора
    (cons `lambda (cons $args $body))
))

;  Таким образом теперь можно написать следующее:
(define Point (Class [x y]
    (define this.x x)
    (define this.y y)
))
; Это объявление развернётся в функцию, описанную в начале.

;  Теперь можно создать точку
(define one (Point 1 1))
;  И поскольку результат исполнения таблица - можно обращаться к полям объекта
(print one.x)
(define one.y (* 3 one.y))
```

Приватные поля класса реализуются как переменные, объявленные в контексте конструктора.
Публичные поля - как переменные, объявленные в this
Пример какого-то класса, реализующего приватные и публичные поля:
```scheme
(define Balance (Class [$amount]
    ;  приватное поле
    (define amount $amount)
    ;  публичное поле
    (define this.change 0)
    ;  публичные методы
    (define this.add (lambda [x]
        ;  изменение приватного поля
        (set! amount (+ x amount))
        ;  изменение публичного поля
        (set! this.change (+ x this.change))
    ))
    (define this.get (lambda [] amount))
))

(define bal (Balance 15))

;  вызов метода
(bal.add 5)
(bal.add 3)
(bal.add 2)
(print bal.change)  ;  10
(print (bal.get))  ;  25
```

#### Синтаксический сахар
В процессе экспериментов я наклепал различных синтаксических конструкций для упрощения кода.  
(Их немного и все их можно найти в **Examples/Bombardo/modules/BaseLang.brd**)

Прежде всего макросы для упрощённого объявления функций и макросов:
```scheme
(defFunct   [FunctName args]
    body
)
(defMacro   [MacroName args]
    body
)
```
Я не стал делать расширенный синтаксис в нативном define что бы не усложнять его, мне показалось что проще все дополнительные функции реализовать макросами.  
При необходимости можно переписать сам define добавив ему функциональности аналогичной define в lisp/scheme
```scheme
(define define (macro ...))
```

Что особенно приятно - макрос defFunct оказался полностью совместим с Class:
```scheme
(define Chick (Class []
    (defFunct [this.Say]
        (print "Chick say Chi!")
    )
    (defFunct [this.Scream]
        (print "Chick say YYYAAAARRRRRRRR!")
    )
))
```

Следующая реализованная конструкция - **let**
```scheme
(let [(a 15)
      (b 'theta')
      (c omega)]
    (print a)  ;  15
    (print b)  ;  theta
    (print c)  ;  omega
)

;  После разворачивания макроса будет выглядеть так:
((lambda []
    (define a 15)
    (define b 'theta')
    (define c omega)
    (print a)
    (print b)
    (print c)
))
```
Как я выше и говорил - в моей реализации нет смысла в конструкции **let**, мой язык получился более структурным нежели lisp.

#### Эвенты
Следующую полезную конструкцию я сделал в **Event.brd**  
Думаю, что такое эвенты - понятно всем, поэтому просто приведу пример:
```scheme
(require "BaseLang" importAll)
(require "Event")

(define myEvent (Event))

(myEvent.Add [lambda [x] (print "Event handler A : " x)])
(myEvent.Add [lambda [x] (print "Event handler B : " x)])

(myEvent.Invoke 15)
;  Event handler A : 15
;  Event handler B : 15

(myEvent.Invoke `EXTRA)
;  Event handler A : EXTRA
;  Event handler B : EXTRA
```

#### Коллекции
Хотя таблицы реализованы нативно, все остальные коллекции лучше делать на **bombardo**.  
Первая коллекция - очередь. Её реализации находятся соответственно в **Queue.brd**.

Изначально я реализовал очередь как объект:
```scheme
(require "Queue" importAll)

(define queue1 (Queue))
(queue1.Push 1)
(queue1.Push 5)
(queue1.Push 12)
(queue1.Push 27)

(print (queue1.Pop))    ;  1
(print (queue1.Pop))    ;  5
(print (queue1.Pop))    ;  12
(print (queue1.Pop))    ;  27
```
Класс Queue имеет следующие методы:
* **Empty?** - проверяет что очередь пустая
* **GetAll** - возвращает список всех элементов
* **Push** - добавляет элемент в очередь
* **Pop** - вынимает элемент
* **Clear** - очищает очередь
  
Но прочитав SICP я сделал более функциональную реализацию очереди:
```scheme
(require "Queue" importAll)

(define queue2 (QueMake))

(QuePush queue2 2)
(QuePush queue2 4)
(QuePush queue2 9)
(QuePush queue2 23)

(print (QuePop queue2)) ;  2
(print (QuePop queue2)) ;  4
(print (QuePop queue2)) ;  9
(print (QuePop queue2)) ;  23
```
Эта реализация представленна набором меторов, оперирующих с списковой структурой очереди.
* **QueMake** - Создаёт новую структуру очереди
* **QuePush** - добавляет элемент в очередь
* **QuePop** - вынимает элемент из очереди
* **QuePeek** - даёт первый элемент, не вынимая его из очереди
* **QueGetList** - возвращает список элементов из очереди
* **QueSetList** - задаёт очереди новый список элементов
* **QueClear** - очищает очередь  
Данная реализация очереди более приближена к языку и его внутреннему устройству, но что лучше использовать - решать вам.
  
В последствии мне понадобились потокобезопасные очереди.  
Поскольку полноценной поддержки многопоточности в языке я пока не делал - то я просто реализовал отдельно очередь в виде C# объекта и предоставил [методы работы с ней](DOCUMENTATION.md#многопоточность).

Следующей коллекцией я сделал массив **Array.brd**, который состоит из списка и счётчика элементов.  
Пока больше никаких коллекций нет.  
Вы можете предложить свои ;)

#### Юнит тесты.
В процессе работы я накидал модуль для юнит тестов, но он получился весьма примитивным и монструозным.  
**По хорошему** нужно сделать полноценную систему, которая будет подгружать другие модули сама и анализировать их (как я писал выше - никто не мешает добавлять прямо в структуру программы метаданные, которые не будут мешать исполнению).

Но пока руки до этого не дошли, поэтому я сделал класс, который исполняет s-выражения, проверяет их соответствие желаемым результатам и в конце выводит отчёт.  
Пример использования этого модуля можно найти в **PatternMatch.brd**.

Засчёт того что макросы исполняются во время рантайма - мне удалось сделать весьма грязный хак - метод Test на самом деле является макросом, что позволяет ему исполнять выражение в правильном контексте.
```scheme
(require "UnitTests" as Unit)

;  Создаём объект-тестировщик и присваиваем ему имя
(define unit (Unit "Math test"))

;  первый аргумент - выражение которое нужно исполнить
;  второй аргумент - ожидаемый результат
(unit.Test (+ 5 7) 12)
(unit.Test (* 5 3) 14)  ;  упс! Никто не отменял ошибок в самих тестах

;  Вызов этого метода выводит на экран информацию о всех проведённых тестах и общую статистику
(unit.Complete)
```
В данном примере вывод будет такой:
```
 -- (+ 5 7)
 -> 12
 -! 12
    successed

 -- (* 5 3)
 -> 14
 -! 15
    failed

Unit Tests Math test complete
    tests: 2
    success: 1
    failed: 1 !!!
```


#### Сопоставление с образцом.
Модуль **PatternMatch.brs** я писал уже почти полностью под влиянием SICP. Большинство функций списаны с учебника с поправкой на перевод на мой диалект языка.

Здесь две главные функции:  
**Match** - проверяет соответствие структуры образцу.
**Образец** - это списковая структура, которая может содержать в себе переменные - символы оканчивающиеся знаками вопроса.  
При сопоставлении проверяется совпадение структур, и находятся значения для переменных.  
Результат - список точечных пар ( переменная . значение )

```scheme
(Match `(who? said hello) `(Jhon said hello))
;  ( ( who? . Jhon ) )

(Match `(banana lies in a where?) (orange lies in a box))
;  null
;  Потому что банан - это не апельсин
```

Вторая функция - **Unify** - сопоставление двух обрацов. Как и **Match** она сравнивает структуры и находит значения для переменных, однако переменные могут быть в обоих структурах одновременно.
```scheme
(Unify `(a? 15 35) `(b? c? b?))
;  ( ( a? . b? ) ( b? . 35 ) ( c? . 15 ) )
```
Как видно из примера - функция в том числе умеет находить связанные переменные.  
Помимо этого данный модуль содержит ещё ряд полезных методов, но думаю для обзора этого хватит.

Сопоставление с образцом - важная часть логического программирования (которое я так же реализовывал по учебнику SICP) и при необходимости отдельно опишу всю систему.

#### Итераторы
Последняя интересная система, написанная на **bombardo** на текущий момент.  








