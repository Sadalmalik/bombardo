[Вернуться на главную](../README.md#оглавление)

# WORK IN PROGRESS

Это обзор языка, здесь я постараюсь кратко описать основные моменты, а так же свои наработки.
Подробное описание всех функций можно найти в [технической документации](DOCUMENTATION.md).

## Оглавление
* [Немного истории](#немного-истории)
* [Основы языка](#основы-языка)
* [Контексты, Окружение](#контексты-окружение)
* [Модульная система](#модульная-система)
* [Наработки](#наработки)

---

### Немного истории
[к оглавлению](#оглавление)

Началось всё с того что я увлёкся идеей искусственного интеллекта.
Сначала стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.

В качестве основы я выбрал семантические сети и уже от них начал экспериментировать.
После многих итераций у меня даже получилась некая база знаний, задающая вопросы (очень глупые)

В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) пришло окончательное понимание, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.

Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.

---

## Основы языка
[к оглавлению](#оглавление)

Как и в обычном Lisp программа состоит из символьных выражений, которые состоят из атомов.

Существуют следующие атомы:
  - Точечная пара
  - Символ
  - Число
  - Строка
  - Флаг (Булево значение) (true | false)
  - Функция
  - Нативный объект (ссылается на любой объект C#)

Точечная пара обозначается в коде следующим образом:
```scheme
;  Пара атомов symbolA и symbolB
( symbolA . symbolB )
```
Список является цепочкой пар.  
Для удобства запили лишние точки и скобки сокращаются.
```scheme
;  Эти две записи эквивалентны
( a . ( b . ( c . null )))
( a b c )
```

Язык поддерживает два типа скобок: круглые и квадратные.
Скобки полностью равнозначны между собой, но нельзя сочетать разные скобки.
```lisp
( exp )  ; Корректно
[ exp ]

( exp ]  ; Некорректно
[ exp )
```

Символьное выражение является списком, голова которого интерпретируется как функция.

Исполнение программы производится сходным с лисплм образом.
```lisp
( procedureName argument1 argument2 ... )
```

Сначала интерпретатор исполняет голову списка procedureName.
Если в результате получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
  - вычисляются ли их аргументы перед вызовом
  - вычисляются ли возвращаемое значение

Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:  
* Символы интерпретируются как ключи по которым производится поиск в текущем и родительском контексте.  
Если значения найти не удалось - исполнение прерывается.  
* Все другие значения (числа, строки, флаги, функции, объекты) остаются без изменений.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора. Но в будущем возможно будет исправлено.

```lisp
;  Объявление функции
(lambda (arguments) body )

;  Объявление макроса
(macros (arguments) body )
```

Кроме того есть форма с явным определением флагов исполнения:
```lisp
(syntax (arg res) (arguments) body )
```
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
```
(lambda (arguments) body )
(syntax (true false) (arguments) body )

(macros (arguments) body )
(syntax (false true) (arguments) body )
```

---

### Контексты, Окружение
[к оглавлению](#оглавление)

Исполнение s-выражений всегда происходит в некотором контексте.
Контекст является таблицей, хранящей пары ключ-значение, где ключ - произвольная строка, а значение - любой атом.
Как было сказано выше - интерпретируя символ интерпретатор просто находит в текущем или родительских контекстах значение для данного символа.

Когда создаётся новая функция - она запоминает текущий контекст. При исполнении функция создаёт новый дочерний данному контекст, в который заносятся аргументы функции.

Когда изучал лисп - я не совсем понял сокральный смысл **let**. 
В моей реализации внутри функции создаётся контекст, ничем не отличающийся от других.  
И внутри него точно так же можно объявлять и изменять переменные. Поэтому надобности в специальной конструкции я не нашёл (хотя для тренировки сдлал её реализацию). Поскольку я пришёл из более структурного языка, то стал писать соответствуюим образом:
```scheme
(define myFunc (lambda [$arg1 $arg2 $arg3]
    ;  Все аргументы объявляются во внутреннем контексте функции
    ;  Контекст создаётся при каждом вызове
    (define $var1 ...)   ;  Объявляет переменную во внутреннем контексте
    (define $var2 ...)
    (define $var3 ...)
	(doSomething ...)
	(generate final result)
))
```

---

### Модульная система
[к оглавлению](#оглавление)

---

### Наработки
[к оглавлению](#оглавление)








