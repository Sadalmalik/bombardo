[Вернуться к оглавлению](../README.md#оглавление)

# WORK IN PROGRESS

## Оглавление
* [Работа со списками](#работа-со-списками)
* [Базовый ввод/вывод](#базовый-вводвывод)
* [Работа с данными](#работа-с-данными)
* [Языковые конструкции](#языковые-конструкции)
* [Логика](#логика)
* [Маткматика](#математика)

---

### Работа со списками
[к оглавлению](#оглавление)

#### cons
Функция **cons** создаёт точечную пару.
* Аргументы: два любых атома (значения по умолчанию null null)
* Результат: точечная пара
```scheme
(cons `A `B) -> (A . B)
```

#### car
Функция **car** возвращает первый элемент точечной пары (голову списка)
* Аргументы: точечная пара (список)
* Результат: атом
```scheme
(car `(A . B)) -> A
```

#### cdr
Функция **cdr** возвращает второй элемент точечной пары (хвост списка)
* Аргументы: точечная пара (список)
* Результат: атом
```scheme
(cdr `(A . B)) -> B
```

#### c[ad]{1,4}r
Как и в обычном лиспе, в бомбардо есть синтаксический сахар для нескольких вызовов car|cdr
В текущей реализации поддерживается до 4 символов a|d
```scheme
;	Эти две записи эквивалентны
(cadddr `(...))
(car (cdr (cdr (cdr `(...)))))
```

#### get
Функция **get** возвращает заданный элемент из списка
* Аргументы:
  - индекс элемента (начиная с 0)
  - список
* Результат: атом
```scheme
(get 2 `(A B C D)) -> C
```

#### last
Функция **last** возвращает последний узел списка (точечную пару, не элемент!)
* Аргумент: список
* Результат: точечная пара
```scheme
(last `(A B C D)) -> (D)
```

#### append
Функция **append** объединяет два списка в один
* Аргументы: список, список
* Результат: список
```scheme
(append `(A B C) `(D E F)) -> (A B C D E F)
```

#### list
Функция **list** создаёт список из своих аргументов
* Аргументы: произвольное колличество атомов
* Результат: список
```scheme
(list `A `B `C `D) -> (A B C D)
```

#### reverse
Функция **reverse** возвращает список с обратным порядком элементов
* Аргументы: список
* Результат: список
```scheme
(reverse `(A B C D)) -> (D C B A)
```

#### each
Функция **each** берёт список и функцию и вызывает функцию для каждого элемента списка
* Аргументы: список
* Результат: null
```scheme
(each `(A B C) print)	;	печатает по очереди A, B и C
```

#### map
Функция **map** берёт список и функцию и вызывает функцию для каждого элемента списка и из результатов составляет новый список
* Аргументы: список, функция
* Результат: список
```scheme
; pow2 возвращает квадрат числа
(map `(1 2 3 4) pow2) -> (1 4 9 16)
```

#### filter
Функция **filter** берёт список и функцию-предикат. Предикат применяется к каждому элементу, если предикат возвращает true - элемент добавляется в возвращаемый список
* Аргументы: список, функция
* Результат: список
```scheme
; even? возвращает true если число чётное, odd? если не чётное
(map `(1 2 3 4 5 6) even?) -> (2 3 6)
(map `(1 2 3 4 5 6) odd?) -> (1 3 5)
```

#### contains?
Функция **contains?** проверяет, есть ли в данном списке заданный элемент
* Аргументы: список, атом
* Результат: true|false
```scheme
(contains? `(1 2 3 4 5 6) 5) -> true
(contains? `(1 2 3 4 5 6) 9) -> false
```

---

### Базовый ввод/вывод
[к оглавлению](#оглавление)

#### print
Функция **print** выводит в консоль все свои аргументы. Строки выводятся без кавычек.
* Аргументы: атомы
* Результат: null
```scheme
(print "Это " `just " " `ohuitelno "!") ; Выведет на экран Это just ohuitelno!
```

#### read
Функция **read** читает ввод пользователя из консоли
* Аргументы: null
* Результат: строка
```scheme
(print (read))  ; просто повторит вводимую строку
```

---

### Работа с данными
[к оглавлению](#оглавление)

#### define
Функция **define** создаёт в текущем контексте новую переменную.
* Аргументы: символ, значение
* Результат: значение
```scheme
(define $variable 15)   ;  Теперь в контексте есть переменная $variable со значением 15
(print $variable)       ;  Выведет на экран значение 15
```

#### set!
Функция **set!** изменяет значение переменной. Сначала переменная ищется в текущем контексте. Если она не найдена - поиск происодит в родительском контексте. Если и там нет - в родителе родителя. И так далее. Если переменной найдено не было - происходит ошибка. 
* Аргументы: символ, новое значение
* Результат: новое значение
```scheme
(set! $variable 25)     ;  Меняем значение переменной из предыдущего примера
(print $variable)       ;  Выведет на экран значение 25
```

#### set-car!
Функция **set-car!** заменяет первый элемент данной точечной пары на новый. 
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```scheme
(define $pair `(A . B))
;       $pair -> (A . B)
(set-car! $pair `X) -> X
;       $pair -> (X . B)
```

#### set-cdr!
Функция **set-cdr!** заменяет второй элемент данной точечной пары на новый
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```scheme
(define $pair `(A . B))
;       $pair -> (A . B)
(set-cdr! $pair `X) -> X
;       $pair -> (A . X)
```

---

### Языковые конструкции
[к оглавлению](#оглавление)

#### nope
Функция **nope** полностью игнорирует свои аргументы и ничего не возвращает. Её предназначение - исключать некоторые блоки кода из исполнения.
* Аргументы: что угодно
* Результат: null
```scheme
(nope Всё что угодно! Исключение - закрывающая скобка. 1 15 "lalala" ------!!!!!) -> null
```

#### quote
Функция **quote** берёт свой аргумент и возвращает его не вызывая интерпретации. Таким образом можно записывать в коде символы как без их обращения к контексту.
* Аргументы: атом
* Результат: атом
```scheme
(quote A) -> A

;	У данной функции есть синтаксический сахар - кавычка
`A -> A
```

#### parse
Функция **parse** берёт строку и парсит из неё символьное выражение.
* Аргументы: строка
* Результат: атом
```scheme
(parse "(X Y Z)") -> (X Y Z)
```

#### eval
Функция **eval** берёт символьное выражение и исполняет его в текущем контексте
* Аргументы: список
* Результат: атом
```scheme
(eval `(car `(A . B))) -> A
```

#### block
Функция **block** - это блок кода.
Он берёт множество символьных выражений, исполняет их последовательно и возвращает результат последнего выражения.
* Аргументы: список [список [список ...]]
* Результат: атом
```scheme
(block
    (print `A)  ;  печатает A
    (print `B)  ;  печатает B
    `X          ;  возвращает X как результат
)
```

#### cond
Функция **cond** - это условное выражения. Оно принимает произвольное колличество аргументов, каждый из которых должен быть списком.
**cond** последовательно исполняет первый элемент каждого списка и если результат исполнения **true** - выполняет последовательно остальные элементы данного списка (как и block) и возвращает результат последнего.
Если ни один из списков не был выполнен - возвращает null
* Аргументы: список [список [список ...]]
* Результат: атом | null
```scheme
(cond   [(even? 5)  ;  Условие
            ;	выполняемый код
            (print "5 is even!")
            `even]
        [(odd? 5)
            (print "5 is odd!")
            (print "do something else!")
            `odd]
        [true   ;  В качестве условия можно поставить конечное значение,
                ;  сделав таким образом всегда исполняемую ветку
            "Разрыв пространства-времени"]
)
```

#### if
Функция **if** - так же условное выражение. Требует два или три аргумента. Исполняет первый аргумент и если он вернул true исполняет второй аргумент. В противном случае если есть третий аргумент - исполняет его.
* Аргументы: список список [список]
* Результат: атом
```scheme
(if [< 0 10]
    [print "0 < 10"]
    [print "0 > 10"]
)
```

#### while
Функция **while** - цикл. Требует два или более аргумента. Исполняет первый аргумент и если он вернул true - исполняет все остальные аргументы последовательно. Дойдя до конца вновь исполняет первый аргумент. Исполнение происходит до тех пор пока первый аргумент не вернёт false
* Аргументы: список список [список ...]
* Результат: null
```scheme
(define $i 5)   ;  объявляем переменную $i
(while [< 0 $i] ;  проверяем что $i больше 0
    ;  Уменьшаем $i на единицу
    (set! $i (- $i 1))
    ;  Выводим $i в консоль
    (print $i)
)
```

#### until
Функция **until** - цикл. Полностью аналогичен **while**, но исполняется пока первый аргумент возвращает false. Как только он вернёт true - прерывается.
* Аргументы: список список [список ...]
* Результат: null
```scheme
(define $i 5)   ;  объявляем переменную $i
(until [== 0 $i];  проверяем не равен ли $i нулю
    ;  Уменьшаем $i на единицу
    (set! $i (- $i 1))
    ;  Выводим $i в консоль
    (print $i)
)
```

#### lambda
Функция **lambda** - объявление функции.
```scheme
```

#### macros
Функция **macros**
```scheme
```

#### syntax
Функция **syntax**
```scheme
```

#### apply
Функция **apply**
```scheme
```

#### macro-expand
Функция **macro-expand**
```scheme
```

#### error
Функция **error**
```scheme
```

#### toString
Функция **toString**
```scheme
```

#### fromString
Функция **fromString**
```scheme
```

#### symbolName
Функция **symbolName**
```scheme
```

#### symbolMake
Функция **symbolMake**
```scheme
```

#### getContext
Функция **getContext**
```scheme
```

#### getContextParent
Функция **getContextParent**
```scheme
```

---

### Логика
[к оглавлению](#оглавление)

#### Предикаты типов
Предикаты **null?**, **empty?**, **symbol?**, **pair?**, **list?**, **string?**, **bool?**, **number?** и **proc?** проверяют что заданный атом является данным объектом.
* Аргументы: атом
* Результат: true|false
```scheme
(symbol? `sym)      ;  true
(symbol? 5035)      ;  false
(symbol? `(a . b))  ;  false

(pair? `sym)        ;  false
(pair? 5035)        ;  false
(pair? `(a . b))    ;  true

(number? `sym)      ;  false
(number? 5035)      ;  true
(number? `(a . b))  ;  false
```

#### Равенство
Предикаты **eq?**, **neq?** сравнивают два атома и возвращают true|false в зависимости от того равны они или нет. Если сравнивается точечная пара - то происходит поэлементное сравнение.
* Аргументы: атом атом
* Результат: true|false
```scheme
(eq? 15 15)                 ;  true
(eq? 15 `X)                 ;  false
(eq? 0 `(1 . 2))            ;  false

(neq? `(a b c) `(R Q T))    ;  true
(neq? `(a b c) `(a b c))    ;  false
```

#### Логическое отрицание
Операция **not** берёт логическое значение и возвращает противоположное
* Аргументы: true|false
* Результат: false|true
```scheme
(not true)  ;  false
(not false) ;  true
```

#### Логические операции
Операции **and**, **or**, **xor** берут два аргумента и возвращают соответствующие результаты. Колличество аргументов не ограничено
* Аргументы: атом атом [атом ...]
* Результат: true|false
Таблица истинности (все мы её знаем)
A|B|and|or|xor
0|0|0|0|0
0|1|0|1|1
1|0|0|1|1
1|1|1|1|0

#### Импликация
Операция **imp** производит [импликацию](https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F) над двумя аргументами. Если аргументов больше двух, то сначала производится импликация над первыми двумя, затем импликация производится к результату первой импликации и третьему аргументу и так далее, порождая цепочку импликаций.
* Аргументы: true|false true|false [true|false ...]
* Результат: true|false
A|B|imp
0|0|1
0|1|0
1|0|1
1|1|1
```scheme
;  Два нижеследующих выражения эквивалентны
(imp A B C)
(imp (imp A B) C)
```

---

### Математика
[к оглавлению](#оглавление)













