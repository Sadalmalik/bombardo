[Вернуться к оглавлению](../README.md#оглавление)

# IN PROGRESS



### Работа со списками

#### cons
Функция **cons** создаёт точечную пару.
* Аргументы: два любых атома (значения по умолчанию null null)
* Результат: точечная пара
```lisp
(cons `A `B) -> (A . B)
```

#### car
Функция **car** возвращает первый элемент точечной пары (голову списка)
* Аргументы: точечная пара (список)
* Результат: атом
```lisp
(car `(A . B)) -> A
```

#### cdr
Функция **cdr** возвращает второй элемент точечной пары (хвост списка)
* Аргументы: точечная пара (список)
* Результат: атом
```lisp
(cdr `(A . B)) -> B
```

### c[ad]{1,4}r
Как и в обычном лиспе, в бомбардо есть синтаксический сахар для нескольких вызовов car|cdr  
В текущей реализации поддерживается до 4 символов a|d
```lisp
;	Эти две записи эквивалентны
(cadddr `(...))
(car (cdr (cdr (cdr `(...)))))
```

#### get
Функция **get** возвращает заданный элемент из списка
* Аргументы:
  1. индекс элемента (начиная с 0)
  2. список
* Результат: атом
```lisp
(get 2 `(A B C D)) -> C
```

#### last
Функция **last** возвращает последний узел списка (точечную пару, не элемент!)
* Аргумент: список
* Результат: точечная пара
```lisp
(last `(A B C D)) -> (D)
```

#### append
Функция **append** объединяет два списка в один
* Аргументы: список, список
* Результат: список
```lisp
(append `(A B C) `(D E F)) -> (A B C D E F)
```

#### list
Функция **list** создаёт список из своих аргументов
* Аргументы: произвольное колличество атомов
* Результат: список
```lisp
(list `A `B `C `D) -> (A B C D)
```

#### reverse
Функция **reverse** возвращает список с обратным порядком элементов
* Аргументы: список
* Результат: список
```lisp
(reverse `(A B C D)) -> (D C B A)
```

#### each
Функция **each** берёт список и функцию и вызывает функцию для каждого элемента списка
* Аргументы: список
* Результат: null
```lisp
(each `(A B C) print)	;	печатает по очереди A, B и C
```

#### map
Функция **map** берёт список и функцию и вызывает функцию для каждого элемента списка и из результатов составляет новый список
* Аргументы: список, функция
* Результат: список
```lisp
; pow2 возвращает квадрат числа
(map `(1 2 3 4) pow2) -> (1 4 9 16)
```

#### filter
Функция **filter** берёт список и функцию-предикат. Предикат применяется к каждому элементу, если предикат возвращает true - элемент добавляется в возвращаемый список
* Аргументы: список, функция
* Результат: список
```lisp
; even? возвращает true если число чётное, odd? если не чётное
(map `(1 2 3 4 5 6) even?) -> (2 3 6)
(map `(1 2 3 4 5 6) odd?) -> (1 3 5)
```

#### contains?
Функция **contains?** проверяет, есть ли в данном списке заданный элемент
* Аргументы: список, атом
* Результат: true|false
```lisp
(contains? `(1 2 3 4 5 6) 5) -> true
(contains? `(1 2 3 4 5 6) 9) -> false
```



### Языковые конструкции




### Работа с данными

#### set-car!
Функция **set-car!** заменяет первый элемент данной точечной пары на новый
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```lisp
(define $pair `(A . B))
;	$pair -> (A . B)
(set-car! $pair `X) -> X
;	$pair -> (X . B)
```

#### set-cdr!
Функция **set-cdr!** заменяет второй элемент данной точечной пары на новый
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```lisp
(define $pair `(A . B))
;	$pair -> (A . B)
(set-cdr! $pair `X) -> X
;	$pair -> (A . X)
```











#### nope
Функция **nope** полностью игнорирует свои аргументы и ничего не возвращает. Её предназначение - исключать некоторые блоки кода из исполнения.
* Аргументы: что угодно
* Результат: null
```lisp
(nope Всё что угодно! Исключение - закрывающая скобка. 1 15 "lalala" ------!!!!!) -> null
```

#### quote
Функция **quote** берёт свой аргумент и возвращает его не вызывая интерпретации. Таким образом можно записывать в коде символы как без их обращения к контексту.
* Аргументы: атом
* Результат: атом
```lisp
(quote A) -> A

;	У данной функции есть синтаксический сахар - кавычка
`A -> A
```

#### parse
Функция **parse** берёт строку и парсит из неё символьное выражение.
* Аргументы: строка
* Результат: атом
```lisp
(parse "(X Y Z)") -> (X Y Z)
```

#### eval
Функция **eval** берёт символьное выражение и исполняет его в текущем контексте
* Аргументы: список
* Результат: атом
```lisp
(eval `(car `(A . B))) -> A
```

#### block
Функция **block** - это блок кода.  
Он берёт множество символьных выражений, исполняет их последовательно и возвращает результат последнего выражения.  
* Аргументы: список [список [список ...]]
* Результат: атом
```lisp
(block
	(print `A)	;	печатает A
	(print `B)	;	печатает B
	`X	;	возвращает X как результат
)
```

#### cond
Функция **cond** - это условное выражения. Оно принимает произвольное колличество аргументов, каждый из которых должен быть списком.
**cond** последовательно исполняет первый элемент каждого списка и если результат исполнения **true** - выполняет последовательно остальные элементы данного списка (как и block) и возвращает результат последнего.  
Если ни один из списков не был выполнен - возвращает null
* Аргументы: список [список [список ...]]
* Результат: атом | null
```lisp
(cond	[(even? 5)	;	Условие
			;	выполняемый код
			(print "5 is even!")
			`even]
		[(odd? 5)
			(print "5 is odd!")
			(print "do something else!")
			`odd]
		[true	;	В качестве условия можно поставить конечное значение, сделав таким образом всегда исполняемую ветку
			"Разрыв пространства-времени"]
)
```

#### if
Функция **if** - так же условное выражение. Требует два или три аргумента. Исполняет первый аргумент и если он вернул true исполняет второй аргумент. В противном случае если есть третий аргумент - исполняет его.
* Аргументы: список список [список]
* Результат: атом
```lisp
(if	[< 0 10]
	[print "0 < 10"]
	[print "0 > 10"]
)
```

#### while
Функция **while** - цикл. Требует два или более аргумента. Исполняет первый аргумент и если он вернул true - исполняет все остальные аргументы последовательно. Дойдя до конца вновь исполняет первый аргумент. Исполнение происходит до тех пор пока первый аргумент не вернёт false
* Аргументы: список список [список ...]
* Результат: null
```lisp
(define $i 5)	;	объявляем переменную $i
(while [< 0 $i]	;	проверяем что $i больше 0
	;	Уменьшаем $i на единицу
	(set! $i (- $i 1))
	;	Выводим $i в консоль
	(print $i)
)
```

#### until
Функция **until** - цикл. Полностью аналогичен **while**, но исполняется пока первый аргумент возвращает false. Как только он вернёт true - прерывается.
* Аргументы: список список [список ...]
* Результат: null
```lisp
(define $i 5)	;	объявляем переменную $i
(until [== 0 $i];	проверяем не равен ли $i нулю
	;	Уменьшаем $i на единицу
	(set! $i (- $i 1))
	;	Выводим $i в консоль
	(print $i)
)
```


#### lambda
Функция **lambda** - объявление функции.
```lisp
```

#### macros
Функция **macros**
```lisp
```

#### syntax
Функция **syntax**
```lisp
```

#### apply
Функция **apply**
```lisp
```

#### macro-expand
Функция **macro-expand**
```lisp
```

#### error
Функция **error**
```lisp
```



#### print
Функция **print**
```lisp
```

#### read
Функция **read**
```lisp
```

#### define
Функция **define**
```lisp
```

#### set!
Функция **set!**
```lisp
```

#### toString
Функция **toString**
```lisp
```

#### fromString
Функция **fromString**
```lisp
```

#### symbolName
Функция **symbolName**
```lisp
```

#### symbolMake
Функция **symbolMake**
```lisp
```

#### getContext
Функция **getContext**
```lisp
```

#### getContextParent
Функция **getContextParent**
```lisp
```










