[Вернуться к оглавлению](../README.md#оглавление)

# WORK IN PROGRESS

Это техническая документация, здесь приведён список всех уже реализованных функций и их короткое описание.

## Оглавление
* [Замечания](#замечания)
* [Работа со списками](#работа-со-списками)
* [Базовый ввод/вывод](#базовый-вводвывод)
* [Работа с данными](#работа-с-данными)
* [Языковые конструкции](#языковые-конструкции)
* [Логика](#логика)
* [Математика](#математика)

---

### Замечания
[к оглавлению](#оглавление)

Многие функции реализуют цепное исполнение (свёртку). Такие функции принимают произвольное число аргументов и последовательно применяются сначала к первым двум аргументам, затем к результату и третьему аргументу, затем результату и четвёртому и так далее.
```scheme
;  таким образом два нижеследующих выражения эквивалентны
(func a b c d)
(func (func (func a b) c) d)
```

Оформление описания функции:
#### _Имя_
_Короткое (или не очень) описание_
* Аргументы: _список аргументов_
* Результат: _описание результата_
* Пометка что функция цепная (не обязательная)
```scheme
;  Пример кода с данной функцией
```

### Работа со списками
[к оглавлению](#оглавление)

#### cons
Функция **cons** создаёт точечную пару.
* Аргументы: два любых атома (значения по умолчанию null null)
* Результат: точечная пара
```scheme
(cons `A `B) -> (A . B)
```

#### car
Функция **car** возвращает первый элемент точечной пары (голову списка)
* Аргументы: точечная пара (список)
* Результат: атом
```scheme
(car `(A . B)) -> A
```

#### cdr
Функция **cdr** возвращает второй элемент точечной пары (хвост списка)
* Аргументы: точечная пара (список)
* Результат: атом
```scheme
(cdr `(A . B)) -> B
```

#### c[ad]{1,4}r
Как и в обычном лиспе, в бомбардо есть синтаксический сахар для нескольких вызовов car|cdr
В текущей реализации поддерживается до 4 символов a|d
```scheme
;	Эти две записи эквивалентны
(cadddr `(...))
(car (cdr (cdr (cdr `(...)))))
```

#### get
Функция **get** возвращает заданный элемент из списка
* Аргументы:
  - индекс элемента (начиная с 0)
  - список
* Результат: атом
```scheme
(get 2 `(A B C D)) -> C
```

#### last
Функция **last** возвращает последний узел списка (точечную пару, не элемент!)
* Аргумент: список
* Результат: точечная пара
```scheme
(last `(A B C D)) -> (D)
```

#### append
Функция **append** объединяет два списка в один
* Аргументы: список, список
* Результат: список
```scheme
(append `(A B C) `(D E F)) -> (A B C D E F)
```

#### list
Функция **list** создаёт список из своих аргументов
* Аргументы: произвольное колличество атомов
* Результат: список
```scheme
(list `A `B `C `D) -> (A B C D)
```

#### reverse
Функция **reverse** возвращает список с обратным порядком элементов
* Аргументы: список
* Результат: список
```scheme
(reverse `(A B C D)) -> (D C B A)
```

#### each
Функция **each** берёт список и функцию и вызывает функцию для каждого элемента списка
* Аргументы: список, функция
* Результат: null
```scheme
(each `(A B C) print)	;	печатает по очереди A, B и C
```

#### map
Функция **map** берёт список и функцию и вызывает функцию для каждого элемента списка.
Из результатов составляет новый список
* Аргументы: список, функция
* Результат: список
```scheme
; pow2 возвращает квадрат числа
(map `(1 2 3 4) pow2) -> (1 4 9 16)
```

#### filter
Функция **filter** берёт список и функцию-предикат. Предикат применяется к каждому элементу. Если предикат возвращает true - элемент добавляется в возвращаемый список
* Аргументы: список, функция
* Результат: список
```scheme
; even? возвращает true если число чётное, odd? если не чётное
(filter `(1 2 3 4 5 6) even?) -> (2 3 6)
(filter `(1 2 3 4 5 6) odd?) -> (1 3 5)
```

#### contains?
Функция **contains?** проверяет, есть ли в данном списке заданный элемент
* Аргументы: список, атом
* Результат: true|false
```scheme
(contains? `(1 2 3 4 5 6) 5) -> true
(contains? `(1 2 3 4 5 6) 9) -> false
```

---

### Базовый ввод/вывод
[к оглавлению](#оглавление)

#### print
Функция **print** выводит в консоль все свои аргументы. Строки выводятся без кавычек.
* Аргументы: атомы
* Результат: null
```scheme
(print "Это " `just " " `ohuitelno "!") ; Выведет на экран Это just ohuitelno!
```

#### read
Функция **read** читает ввод пользователя из консоли
* Аргументы: null
* Результат: строка
```scheme
(print (read))  ; просто повторит вводимую строку
```

---

### Работа с данными
[к оглавлению](#оглавление)

#### define
Функция **define** создаёт в текущем контексте новую переменную.
* Аргументы: символ, значение
* Результат: значение
```scheme
(define $variable 15)   ;  Теперь в контексте есть переменная $variable со значением 15
(print $variable)       ;  Выведет на экран значение 15
```

#### set!
Функция **set!** изменяет значение переменной. Сначала переменная ищется в текущем контексте. Если она не найдена - поиск происодит в родительском контексте. Если и там нет - в родителе родителя. И так далее. Если переменной найдено не было - происходит ошибка. 
* Аргументы: символ, новое значение
* Результат: новое значение
```scheme
(set! $variable 25)     ;  Меняем значение переменной из предыдущего примера
(print $variable)       ;  Выведет на экран значение 25
```

#### set-car!
Функция **set-car!** заменяет первый элемент данной точечной пары на новый. 
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```scheme
(define $pair `(A . B))
;       $pair -> (A . B)
(set-car! $pair `X) -> X
;       $pair -> (X . B)
```

#### set-cdr!
Функция **set-cdr!** заменяет второй элемент данной точечной пары на новый
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```scheme
(define $pair `(A . B))
;       $pair -> (A . B)
(set-cdr! $pair `X) -> X
;       $pair -> (A . X)
```

---

### Языковые конструкции
[к оглавлению](#оглавление)

#### nope
Функция **nope** полностью игнорирует свои аргументы и ничего не возвращает. Её предназначение - исключать некоторые блоки кода из исполнения.
* Аргументы: что угодно
* Результат: null
```scheme
(nope Всё что угодно! Исключение - закрывающая скобка. 1 15 "lalala" ------!!!!!) -> null
```

#### quote
Функция **quote** берёт свой аргумент и возвращает его не вызывая интерпретации. Таким образом можно записывать в коде символы как без их обращения к контексту.
* Аргументы: атом
* Результат: атом
```scheme
(quote A) -> A

;	У данной функции есть синтаксический сахар - кавычка
`A -> A
```

#### parse
Функция **parse** берёт строку и парсит из неё символьное выражение.
* Аргументы: строка
* Результат: атом
```scheme
(parse "(X Y Z)") -> (X Y Z)
```

#### eval
Функция **eval** берёт символьное выражение и исполняет его в текущем контексте
* Аргументы: список
* Результат: атом
```scheme
(eval `(car `(A . B))) -> A
```

#### block
Функция **block** - это блок кода.
Он берёт множество символьных выражений, исполняет их последовательно и возвращает результат последнего выражения.
* Аргументы: список [список [список ...]]
* Результат: атом
```scheme
(block
    (print `A)  ;  печатает A
    (print `B)  ;  печатает B
    `X          ;  возвращает X как результат
)
```

#### cond
Функция **cond** - это условное выражения. Оно принимает произвольное колличество аргументов, каждый из которых должен быть списком.
**cond** последовательно исполняет первый элемент каждого списка и если результат исполнения **true** - выполняет последовательно остальные элементы данного списка (как и block) и возвращает результат последнего.
Если ни один из списков не был выполнен - возвращает null
* Аргументы: список [список [список ...]]
* Результат: атом | null
```scheme
(cond   [(even? 5)  ;  Условие
            ;	выполняемый код
            (print "5 is even!")
            `even]
        [(odd? 5)
            (print "5 is odd!")
            (print "do something else!")
            `odd]
        [true   ;  В качестве условия можно поставить конечное значение,
                ;  сделав таким образом всегда исполняемую ветку
            "Разрыв пространства-времени"]
)
```

#### if
Функция **if** - так же условное выражение. Требует два или три аргумента. Исполняет первый аргумент и если он вернул true исполняет второй аргумент. В противном случае если есть третий аргумент - исполняет его.
* Аргументы: список список [список]
* Результат: атом
```scheme
(if [< 0 10]
    [print "0 < 10"]
    [print "0 > 10"]
)
```

#### while
Функция **while** - цикл. Требует два или более аргумента. Исполняет первый аргумент и если он вернул true - исполняет все остальные аргументы последовательно. Дойдя до конца вновь исполняет первый аргумент. Исполнение происходит до тех пор пока первый аргумент не вернёт false
* Аргументы: список список [список ...]
* Результат: null
```scheme
(define $i 5)   ;  объявляем переменную $i
(while [< 0 $i] ;  проверяем что $i больше 0
    ;  Уменьшаем $i на единицу
    (set! $i (- $i 1))
    ;  Выводим $i в консоль
    (print $i)
)
```

#### until
Функция **until** - цикл. Полностью аналогичен **while**, но исполняется пока первый аргумент возвращает false. Как только он вернёт true - прерывается.
* Аргументы: список список [список ...]
* Результат: null
```scheme
(define $i 5)   ;  объявляем переменную $i
(until [== 0 $i];  проверяем не равен ли $i нулю
    ;  Уменьшаем $i на единицу
    (set! $i (- $i 1))
    ;  Выводим $i в консоль
    (print $i)
)
```

#### lambda
Функция **lambda** - объявление функции. Первый аргумент - список аргументов функции. Остальные - тело функции. Телюо исполняется так же как в block - последовательно, результат последнего выражения возвращается из функции.
* Аргументы:
  - список аргументов
  - список [список ...]
* Результат: атом (функция)
```scheme
;  Результат можно присвоить переменной
(define pow2 (lambda [x] (* x x)))
```

#### macros
Функция **macros** - объявляет макрос. Как и у **lambda** первый аргумент - список аргументов, остальные - тело макроса.
Макрос должен возвращать исполнимое выражение. Результат исполнения последнего атома повторно исполняется в контексте вызова.
* Аргументы:
  - список аргументов
  - список [список ...]
* Результат: атом (макрос)
```scheme
(define pow2 (macros [x] (list `* x x)))
```

#### syntax
Функция **syntax** - объявляет функцию с заданым синтаксисом. По сути это общая форма, а **lambda** и **macros** являются производными.
* Аргументы:
  - Первый аргумент - список из двух флагов true|false которые указывают, следует ли исполнять аргументы перед вызовом и возвращаемое значение после.
  - Второй аргумент - список аргументов
  - Остальные аргументы - исполняемое тело
* Результат: атом (исполнимый)
```scheme
(define pow2 (syntax (true false) [x] (list `* x x)))
```

#### apply
Функция **apply** применяет заданную функцию к списку аргументов. Это позволяет формировать произвольный список аргументов программно.
* Аргументы:
  - функция
  - список аргументов
* Результат: атом (исполнимый)
```scheme
(define $args (list 3 5 7))
(apply + $args) ;  15

(define $args `([x] (* x x x)))
(apply lambda $args)    ;  функция с аргументом x и телом (* x x x)
```

#### macro-expand
Функция **macro-expand** производит разворачивание макроса с заданными аргуаментами без исполнения его результата в текущем контексте
* Аргументы: выражение с макросом
* Результат: результат исполнения макроса
```scheme
(macro-expand (pow2 5))
```

#### error
Функция **error** бросает исключение.
* Аргументы:
  - строка или символ - тег
  - строка - описание ошибки
* Результат: ошибка (прерывает исполнение)
```scheme
(if [something happens]
	[error tag "Something happens!"])
```

#### toString
Функция **toString** преобразует любой атом в строку.
* Аргументы: атом
* Результат: строка
```scheme
(toString `(15 a b c))  ;  "(15 a b c)"
```

#### symbolName
Функция **symbolName** возвращает имя символа
* Аргументы: символ
* Результат: строка
```scheme
(symbolName `SYMBOL)    ;  "SYMBOL"
```

#### symbolMake
Функция **symbolMake** создаёт символ из строки
* Аргументы: строка
* Результат: символ
```scheme
(symbolMake "SYMBOL")   ;  SYMBOL
```

#### getContext
Функция **getContext** возвращает текущий контекст
* Аргументы: нет
* Результат: таблица
```scheme
(define $ctx (getContext))
;  $ctx -> table (context)
```

#### getContextParent
Функция **getContextParent** возвращает родительский контекст. Если передать в качестве аргумента некоторый контекст - вернёт родитель переданного контекста.
* Аргументы: [таблица]
* Результат: таблица
```scheme
;  Берём родительский контекст
(define $ctx (getContextParent))
;  $ctx -> table (context)
;  Берём родительский контекст
(define $ctx (getContextParent $ctx))
;  $ctx теперь содержит родителя родителя
()
```

---

### Логика
[к оглавлению](#оглавление)

#### Предикаты типов
Предикаты **null?**, **empty?**, **symbol?**, **pair?**, **list?**, **string?**, **bool?**, **number?** и **proc?** проверяют что заданный атом является данным объектом.
* Аргументы: атом
* Результат: true|false
```scheme
(symbol? `sym)      ;  true
(symbol? 5035)      ;  false
(symbol? `(a . b))  ;  false

(pair? `sym)        ;  false
(pair? 5035)        ;  false
(pair? `(a . b))    ;  true

(number? `sym)      ;  false
(number? 5035)      ;  true
(number? `(a . b))  ;  false
```

#### Равенство
Предикаты **eq?**, **neq?** сравнивают два атома и возвращают true|false в зависимости от того равны они или нет. Если сравнивается точечная пара - то происходит поэлементное сравнение.
* Аргументы: атом атом
* Результат: true|false
```scheme
(eq? 15 15)                 ;  true
(eq? 15 `X)                 ;  false
(eq? 0 `(1 . 2))            ;  false

(neq? `(a b c) `(R Q T))    ;  true
(neq? `(a b c) `(a b c))    ;  false
```

#### Логическое отрицание
Операция **not** берёт логическое значение и возвращает противоположное
* Аргументы: true|false
* Результат: false|true
```scheme
(not true)  ;  false
(not false) ;  true
```

#### Логические операции
Операции **and**, **or**, **xor** берут два аргумента и возвращают соответствующие результаты. Колличество аргументов не ограничено
* Аргументы: атом атом [атом ...]
* Результат: true|false
* Это цепные функции (см. [замечания](#замечания))
Таблица истинности (все мы её знаем)

A|B|and|or|xor
-|-|---|--|---
0|0|0|0|0
0|1|0|1|1
1|0|0|1|1
1|1|1|1|0

#### Импликация
Операция **imp** производит [импликацию](https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F) над двумя и более аргументами.
* Аргументы: true|false true|false [true|false ...]
* Результат: true|false
* Это цепная функция (см. [замечания](#замечания))

A|B|imp
-|-|---
0|0|1
0|1|0
1|0|1
1|1|1
```scheme
;  Два нижеследующих выражения эквивалентны
(imp A B C)
(imp (imp A B) C)
```

---

### Математика
[к оглавлению](#оглавление)

Математический функционал представляет собой полное отражение математики, доступной в C#. Просто потому что реализацию я сделал на C#.  
Тип атома number на самом деле может содержать в себе один из примитивных числовых типов - **byte**, **char**, **short**, **int**, **long**, **float** или **double**. В процессе вычисления типы всех чисел приводятся к самому общему. **byte** приводится к **char**, **char** к **short**, к **int** и так далее по порядку. Таким образом если у вас есть сумма трёх **byte** и **double** - результат будет **double**.  
Беззнаковые приводятся к знаковым.

#### Предикаты типов чисел
Предикаты типов чисел проверяют, является ли данное число данным типом.  
Вот полный список предикатов: **byte?**, **ubyte?**, **sbyte?**, **char?**, **short?**, **ushort?**, **int?**, **uint?**, **long?**, **ulong?**, **float?**, **double?**.
Причём если предикат **number?** не проходит, то и не один из типовых предикатов так же не выполнится.  
* Аргументы: число
* Результат: true|false
```scheme
(double? 15)    ;  false
(double? 15.0)  ;  true
```

#### Приведение типов чисел
Для приведения типов чисел служат следующие функции: **byte:**, **ubyte:**, **sbyte:**, **char:**, **short:**, **ushort:**, **int:**, **uint:**, **long:**, **ulong:**, **float:**, **double:**.
При приведении более общего типа чисел к менее общему происходит потеря данных. Как и в любом другом языке.
* Аргументы: число
* Результат: число
```scheme
(byte: 0x3F0)   ;  0xF0
(int: 15.025)   ;  15
```

#### Константы
Есть две математические константы
* **#PI** - число Пи
* **#E** - число Е

#### Математические операции
Основные математические операции: **+** **-** **\*** **/** **%** (остаток от деления)  
Все они принимают произвольное число аргументов (минимум 2)
* Аргументы: число число [число ...]
* Результат: число
* Это цепные функции (см. [замечания](#замечания))
```scheme
;  результат: 10
(+ 1 2 3 4)
(+ (+ (+ 1 2) 3) 4)

;  результат: 10
(/ 1000 2 5 10)
(/ (/ (/ 1000 2) 5) 10)
(/ 1000 (* 2 5 10))
```

#### Min/Max
Функции **min** и **max** берут произвольное число аргументов и находят наименьший и наибольший соответственно.
* Аргументы: число [число ...]
* Результат: число
```scheme
(min -10 -5 0 5 10 20)  ;  -10
(max -10 -5 0 5 10 20)  ;   20
```

#### Возведение в степень
Функция **pow** возводит число в степень. Принимает произвольное число аргументов.  
Обратите внимание что это последовательное возведение в степень, а не степенная башня. Выражение с более чем двумя аргументами будет эквивалентно выражению с двумя аргументами, где второй аргумент - произведение всех.
* Аргументы: число число [число ...]
* Результат: число
* Это цепная функция (см. [замечания](#замечания))
```scheme
(pow 3 2)   ;  3^2 = 9
(pow 3 2 2) ;  (3^2)^2 = 81
;  Эквивалентно:
(pow 3 (* 2 2)) ;  (3^2)^2 = 81
```

#### Математические функции одного аргумента
**abs** - берёт число и возвращает его абсолютное значение  
**sign** - берёт число, если оно отрицательно то возвращает -1, иначе 1  
**ceil** - берёт дробное число и возвращает ближайшее целое число, большее данного  
**floor** - берёт дробное число и возвращает ближайшее целое число, меньшее данного  
**trunc** - возвращает целую часть от данного числа  
**sqrt** - возвращает квадратный корень числа  
**exp** - находит экспоненту числа (возводит число e в степень данного числа)  
**ln** - находит натуральный логарифм  
**ld** - находит десятичный логарифм  
* Аргументы: число
* Результат: число

#### Тригонометрические функции
**sin**, **cos**, **tan** - прямые тригонометрические функции  
**asin**, **acos**, **atan** - обратные тригонометрические функции  
**sinh**, **cosh** и **tanh** - гиперболические функции  
Все они принимают одно число и возвращают число.
* Аргументы: число
* Результат: число
```scheme
(cos (* 2 #PI))
```

Функция **atan2** принимает произвольное число аргументов. Первый аргумент - противолежащий катет, второй - прилежащий.
* Аргументы: число число [число ...]
* Результат: число
* Это цепная функция (см. [замечания](#замечания))
```scheme
(atan2 15 25)
(atan2 15 25 80 1 1)
;  Я не знаю, какой геометрический смысл этого,
;  но просто реализация цепных функций получилась достаточно простой что бы засунуть её везде :D
```

#### Битовые операции
**&** - побитовое И  
**|** - побитовое ИЛИ  
**^** - побитовое исключающее ИЛИ  
**<<** - побитовый сдвиг влево  
**>>** - побитовое сдвиг вправо  
* Аргументы: число число [число ...]
* Результат: число
* Это цепные функции (см. [замечания](#замечания))
```scheme
(& 0b1011 0b0110)   ;  0b0010
(| 0b0001 0b0010 0b0100 0b1000) ;  0b1111

(<< 0b0001 3)   ;  0x1000
(>> 0b1000 3)   ;  0x0001
```

#### Сравнения
**<** - проверяет что первое число меньше второго, второе третьего и так далее  
**>** - проверяет что первое число больше второго  
**<=** - меньше или равно  
**>=** - больше или равно  
**!=** - неравно  
**==** - равно  
Функции сравнения принимают произвольное число аргументов, но цепочка прирывается если хотя бы одно условие не выполнилось.
* Аргументы: число число [число ...]
* Результат: число
```scheme
(< 3 5 7)   ;  true
(< 3 7 5)   ;  false
```

---

### Таблицы
[к оглавлению](#оглавление)
Таблицы сейчас реализованы через C# System.Collections.Generic.Dictionary<string, Atom>.  
Ключ таблицы - строка или символ (который по сути та же строка), значение - любой произвольный атом

#### table
Функция **table** создаёт новую таблицу. Опционально заполняет её данными.  
Данные задаются списками из двух элементов, где первый элемент ключ, второй значение.
* Аргументы: [(key1 value1) [(key2 value2) ...]]
* Результат: нативный объект
```scheme
(define $myTable (table `(key` "HYDROGEN")))
;  $myTable -> native object
```

#### table?
Предикат **table?** проверяет, является ли данный атом (нативный объект) таблицей
* Аргументы: атом
* Результат: true|false
```scheme
(table? 1015)       ;  false
(table? $myTable)   ;  true
```

#### tableGet
Функция **tableGet** берёт из таблицы значение по заданному ключу
* Аргументы: символ|строка
* Результат: атом
```scheme
(tableGet $myTable "key1")  ;  "HYDROGEN"
```

#### tableSet
Функция **tableSet** добавляет в таблицу новые значения.  
Синтаксис такой же как при создании таблицы - списки из двух элементов (ключ значение).
* Аргументы: таблица, [(key1 value1) [(key2 value2) ...]]
* Результат: null
```scheme
(tableSet $myTable `(key2 "OXYGEN"))
```

#### tableRemove
Функция **tableRemove** удаляет из таблицы элемент с заданным ключом
* Аргументы: таблица, ключ
* Результат: null
```scheme
(tableRemove $myTable `key1)
```

#### tableClear
Функция **tableClear** удаляет из таблицы всё.
* Аргументы: таблица
* Результат: null
```scheme
(tableClear $myTable)
```

#### tableImport
Функция **tableImport** импортирует из таблицы значение по ключу в текущий контекст.
* Аргументы: таблица, ключ
* Результат: null
```scheme
(tableSet $myTable `(extra "some value"))
(tableImport $myTable `extra)
;  теперь в текущем контексте есть переменная extra со значением "some value"
(print extra)   ;  выведет some value
```

#### tableImportAll
Функция **tableImportAll** импортирует все значения из таблицы в текущий контекст.
* Аргументы: таблица
* Результат: null
```scheme
(tableSet $myTable `(key1 "A") `(key2 "B") `(key3 "C"))
(tableImportAll $myTable)
(print key1)    ;  выведет A
(print key2)    ;  выведет B
(print key3)    ;  выведет C
```

#### tableEach
Функция **tableEach** берёт таблицу и применяет заданную функцию к каждому элементу таблицы.  
В функцию передаётся два аргумета - ключ (строка) и значение (атом).
* Аргументы: таблица, функция
* Результат: null
```scheme
(tableEach $myTable
    (lambda [key value]
            [print key]
            [print value]
    ))
;  С учётом всех предыдущих примеров вывод будет такой:
;   extra
;   some value
;   key1
;   A
;   key2
;   B
;   key3
;   C
```

---

### ааа
[к оглавлению](#оглавление)

### ааа
[к оглавлению](#оглавление)

### 
[к оглавлению](#оглавление)



* [Математика](#математика)



