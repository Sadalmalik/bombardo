[Вернуться к оглавлению](../README.md#оглавление)

# IN PROGRESS

---

### Работа со списками

#### cons
Функция **cons** создаёт точечную пару.
* Аргументы: два любых атома (значения по умолчанию null null)
* Результат: точечная пара
```scheme
(cons `A `B) -> (A . B)
```

#### car
Функция **car** возвращает первый элемент точечной пары (голову списка)
* Аргументы: точечная пара (список)
* Результат: атом
```scheme
(car `(A . B)) -> A
```

#### cdr
Функция **cdr** возвращает второй элемент точечной пары (хвост списка)
* Аргументы: точечная пара (список)
* Результат: атом
```scheme
(cdr `(A . B)) -> B
```

### c[ad]{1,4}r
Как и в обычном лиспе, в бомбардо есть синтаксический сахар для нескольких вызовов car|cdr
В текущей реализации поддерживается до 4 символов a|d
```scheme
;	Эти две записи эквивалентны
(cadddr `(...))
(car (cdr (cdr (cdr `(...)))))
```

#### get
Функция **get** возвращает заданный элемент из списка
* Аргументы:
  - индекс элемента (начиная с 0)
  - список
* Результат: атом
```scheme
(get 2 `(A B C D)) -> C
```

#### last
Функция **last** возвращает последний узел списка (точечную пару, не элемент!)
* Аргумент: список
* Результат: точечная пара
```scheme
(last `(A B C D)) -> (D)
```

#### append
Функция **append** объединяет два списка в один
* Аргументы: список, список
* Результат: список
```scheme
(append `(A B C) `(D E F)) -> (A B C D E F)
```

#### list
Функция **list** создаёт список из своих аргументов
* Аргументы: произвольное колличество атомов
* Результат: список
```scheme
(list `A `B `C `D) -> (A B C D)
```

#### reverse
Функция **reverse** возвращает список с обратным порядком элементов
* Аргументы: список
* Результат: список
```scheme
(reverse `(A B C D)) -> (D C B A)
```

#### each
Функция **each** берёт список и функцию и вызывает функцию для каждого элемента списка
* Аргументы: список
* Результат: null
```scheme
(each `(A B C) print)	;	печатает по очереди A, B и C
```

#### map
Функция **map** берёт список и функцию и вызывает функцию для каждого элемента списка и из результатов составляет новый список
* Аргументы: список, функция
* Результат: список
```scheme
; pow2 возвращает квадрат числа
(map `(1 2 3 4) pow2) -> (1 4 9 16)
```

#### filter
Функция **filter** берёт список и функцию-предикат. Предикат применяется к каждому элементу, если предикат возвращает true - элемент добавляется в возвращаемый список
* Аргументы: список, функция
* Результат: список
```scheme
; even? возвращает true если число чётное, odd? если не чётное
(map `(1 2 3 4 5 6) even?) -> (2 3 6)
(map `(1 2 3 4 5 6) odd?) -> (1 3 5)
```

#### contains?
Функция **contains?** проверяет, есть ли в данном списке заданный элемент
* Аргументы: список, атом
* Результат: true|false
```scheme
(contains? `(1 2 3 4 5 6) 5) -> true
(contains? `(1 2 3 4 5 6) 9) -> false
```

---

### Базовый ввод/вывод

#### print
Функция **print** выводит в консоль все свои аргументы. Строки выводятся без кавычек.
* Аргументы: атомы
* Результат: null
```scheme
(print "Это " `just " " `ohuitelno "!") ; Выведет на экран Это just ohuitelno!
```

#### read
Функция **read** читает ввод пользователя из консоли
* Аргументы: null
* Результат: строка
```scheme
(print (read))  ; просто повторит вводимую строку
```

---

### Работа с данными

#### define
Функция **define** создаёт в текущем контексте новую переменную.
* Аргументы: символ, значение
* Результат: значение
```scheme
(define $variable 15)   ;  Теперь в контексте есть переменная $variable со значением 15
(print $variable)       ;  Выведет на экран значение 15
```

#### set!
Функция **set!** изменяет значение переменной. Сначала переменная ищется в текущем контексте. Если она не найдена - поиск происодит в родительском контексте. Если и там нет - в родителе родителя. И так далее. Если переменной найдено не было - происходит ошибка. 
* Аргументы: символ, новое значение
* Результат: новое значение
```scheme
(set! $variable 25)     ;  Меняем значение переменной из предыдущего примера
```

#### set-car!
Функция **set-car!** заменяет первый элемент данной точечной пары на новый. 
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```scheme
(define $pair `(A . B))
;	$pair -> (A . B)
(set-car! $pair `X) -> X
;	$pair -> (X . B)
```

#### set-cdr!
Функция **set-cdr!** заменяет второй элемент данной точечной пары на новый
* Аргументы: точечная пара
* Результат: атом, который был присвоен
```scheme
(define $pair `(A . B))
;	$pair -> (A . B)
(set-cdr! $pair `X) -> X
;	$pair -> (A . X)
```

---

### Языковые конструкции

#### nope
Функция **nope** полностью игнорирует свои аргументы и ничего не возвращает. Её предназначение - исключать некоторые блоки кода из исполнения.
* Аргументы: что угодно
* Результат: null
```scheme
(nope Всё что угодно! Исключение - закрывающая скобка. 1 15 "lalala" ------!!!!!) -> null
```

#### quote
Функция **quote** берёт свой аргумент и возвращает его не вызывая интерпретации. Таким образом можно записывать в коде символы как без их обращения к контексту.
* Аргументы: атом
* Результат: атом
```scheme
(quote A) -> A

;	У данной функции есть синтаксический сахар - кавычка
`A -> A
```

#### parse
Функция **parse** берёт строку и парсит из неё символьное выражение.
* Аргументы: строка
* Результат: атом
```scheme
(parse "(X Y Z)") -> (X Y Z)
```

#### eval
Функция **eval** берёт символьное выражение и исполняет его в текущем контексте
* Аргументы: список
* Результат: атом
```scheme
(eval `(car `(A . B))) -> A
```

#### block
Функция **block** - это блок кода.
Он берёт множество символьных выражений, исполняет их последовательно и возвращает результат последнего выражения.
* Аргументы: список [список [список ...]]
* Результат: атом
```scheme
(block
    (print `A)  ;  печатает A
    (print `B)  ;  печатает B
    `X          ;  возвращает X как результат
)
```

#### cond
Функция **cond** - это условное выражения. Оно принимает произвольное колличество аргументов, каждый из которых должен быть списком.
**cond** последовательно исполняет первый элемент каждого списка и если результат исполнения **true** - выполняет последовательно остальные элементы данного списка (как и block) и возвращает результат последнего.
Если ни один из списков не был выполнен - возвращает null
* Аргументы: список [список [список ...]]
* Результат: атом | null
```scheme
(cond   [(even? 5)  ;  Условие
            ;	выполняемый код
            (print "5 is even!")
            `even]
        [(odd? 5)
            (print "5 is odd!")
            (print "do something else!")
            `odd]
        [true   ;  В качестве условия можно поставить конечное значение,
                ;  сделав таким образом всегда исполняемую ветку
            "Разрыв пространства-времени"]
)
```

#### if
Функция **if** - так же условное выражение. Требует два или три аргумента. Исполняет первый аргумент и если он вернул true исполняет второй аргумент. В противном случае если есть третий аргумент - исполняет его.
* Аргументы: список список [список]
* Результат: атом
```scheme
(if [< 0 10]
    [print "0 < 10"]
    [print "0 > 10"]
)
```

#### while
Функция **while** - цикл. Требует два или более аргумента. Исполняет первый аргумент и если он вернул true - исполняет все остальные аргументы последовательно. Дойдя до конца вновь исполняет первый аргумент. Исполнение происходит до тех пор пока первый аргумент не вернёт false
* Аргументы: список список [список ...]
* Результат: null
```scheme
(define $i 5)   ;  объявляем переменную $i
(while [< 0 $i] ;  проверяем что $i больше 0
    ;  Уменьшаем $i на единицу
    (set! $i (- $i 1))
    ;  Выводим $i в консоль
    (print $i)
)
```

#### until
Функция **until** - цикл. Полностью аналогичен **while**, но исполняется пока первый аргумент возвращает false. Как только он вернёт true - прерывается.
* Аргументы: список список [список ...]
* Результат: null
```scheme
(define $i 5)   ;  объявляем переменную $i
(until [== 0 $i];  проверяем не равен ли $i нулю
    ;  Уменьшаем $i на единицу
    (set! $i (- $i 1))
    ;  Выводим $i в консоль
    (print $i)
)
```

#### lambda
Функция **lambda** - объявление функции.
```scheme
```

#### macros
Функция **macros**
```scheme
```

#### syntax
Функция **syntax**
```scheme
```

#### apply
Функция **apply**
```scheme
```

#### macro-expand
Функция **macro-expand**
```scheme
```

#### error
Функция **error**
```scheme
```

#### toString
Функция **toString**
```scheme
```

#### fromString
Функция **fromString**
```scheme
```

#### symbolName
Функция **symbolName**
```scheme
```

#### symbolMake
Функция **symbolMake**
```scheme
```

#### getContext
Функция **getContext**
```scheme
```

#### getContextParent
Функция **getContextParent**
```scheme
```










