
		Итак, я хочу преобразовать главный алгоритм из рекурсивного в плоский с явной обработкой стека
		Стек надо представить в виде всё той же лисповой структуры...
		Как происходит исполнение выражения
		
		(
		    (phase expression context)
		    
		    (phase expression context)
		    (phase expression context)
		    (phase expression context)
		    .
		    null
		)
		
		phase:
			-init-
		    -head-
		    -args-
		    -body-
		
		(* (- 5 3) (+ 7 15))
		eval
		()
		
		
		
		Рекурсивный интерпретатор:
		Старт
			Если выражение - атом, то:
				Ищем значение атома
				Если значения нет, то:
					Ошибка
				Возвращаем значение атома
			Если выражение - списов, то:
				Вызываем интерпретацию головы
				Получаем результат
				Если результат - НЕ атом, то:
					Вызываем интерпретацию повторно
				Если результат - НЕ функция, то:
					Ошибка
				Составляем список аргументов
				Если функция требует интерпретацию аргументов, то:
					Для каждого аргумента вызываем интерпретацию
					Соствляем новый список аргументов
				Вызываем функцию со списком аргументов
				Если функция требует интерпретацию результата, то:
					Вызываем интерпретацию результата
				Возвращаем результат
			Если непонятно что, то:
				Ошибка
		
		Если нужно интерпретировать блок кода, то:
			Просто последовательно вызываем интерпретацию каждого элемента блока
			При этом можно собирать все возвращаемые значения
			или только последнее
		
		
		
		
		Нерекурсивный интерпретатор:
		Ставим первое выражение в стек
		Старт
			Если длинна стека больше лимита, то:
				Ошибка
			Если первый вход в кадр на стеке, то:	
				Если текущее выражение в кадре - атом, то:
					Найти значение атома
					снять со стека кадр
					записываем значение атома
					Переходим на Старт
				Если выражение - список, то:
					Взять голову списка
					создать новый кадр стека с выражением в голове текущего
					Переходим на Старт
			Если повторный вход (возврат значения из вложенного вызова), то:		
				Если возврат для головы, то:
					Проверяем что голова - это исполнимая функция
					Если нет, то:
						Ошибка
					Проверяем, требуется ли исполнение аргументов
					Если да, то:
						Инициируем обход аргументов
						создаём кадр с первым аргументом
						Переходим на Старт
					Если нет, то:
						Вызываем функцию с полученным списком аргументов
						Функция возвращает значение
						Если возвращаемое значение требует исполнения, то:	
							Создаём кадр с возвращаемым
							Переходим на Старт
						Если нет, то:
							снимаем со стека кадр
							записываем значение возврата
							Переходим на Старт
				Если возврат для аргумента
					Сохраняем возвращённый аргумент
					Если есть ещё аргументы, то:
						Создаём кадр с новым аргументом
						Переходим на Старт
					Вызываем функцию с полученным списком аргументов
					Функция возвращает значение
					Если возвращаемое значение требует исполнения, то:	
						Создаём кадр с возвращаемым
						Переходим на Старт
					Если нет, то:
						снимаем со стека кадр
						записываем значение возврата
						Переходим на Старт
				Если возврат для результата функции (исполненного), то:
					снимаем со стека кадр
					записываем значение возврата
					Переходим на Старт
		
		Функции которые данный алгоритм исполняет - простые математические функции
			не способные менять окружение
			не способные вызывать исполнение других символьных выражений
			Функция должна принимать аргумент и возвращать значение.
			Никаких побочных эффектов.
		Так же тут не учтены функции написанные на самом языке.
		Для реализации поддержки блоков кода понадобиться писать отдельный набор стейтов.
		
		Что бы реализовать функции вроде условий, циклов, работу с переменными и вызов исполнения
			Придётся расширять набор стейтов для каждого случая ОТДЕЛЬНО
		







